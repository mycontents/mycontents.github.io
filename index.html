<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Contents</title>

  <style>
    :root{
      --bg:#0d1117;
      --panel:#161b22;
      --panel2:#0f141b;
      --border:#30363d;
      --border2:#21262d;

      --text:#c9d1d9;
      --muted:#6e7681;
      --muted2:#484f58;

      --blue:#58a6ff;
      --red:#f85149;
      --green:#238636;

      --r10:10px;
      --tap:transparent;
    }

    *{ box-sizing:border-box; margin:0; padding:0; }

    body{
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:var(--bg);
      color:var(--text);
      min-height:100vh;
      padding:16px;
    }

    .container{ max-width:800px; margin:0 auto; position:relative; }

    /* ===== Sticky header ===== */
    header{
      position:sticky;
      top:0;
      z-index:100;
      background:var(--bg);
      padding:10px 0;
      border-bottom:1px solid var(--border2);
      margin-bottom:12px;
    }

    .header-row{
      display:flex;
      align-items:center;
      gap:10px;
    }

    .section-btn{
      height:40px;
      min-width:170px;
      padding:0 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;

      background:var(--border2);
      color:var(--text);
      border:1px solid var(--border);
      border-radius:var(--r10);
      cursor:pointer;
      -webkit-tap-highlight-color:var(--tap);
      flex:0 0 auto;
    }
    .section-btn:hover{ border-color:var(--blue); }
    .section-btn:active{ transform:translateY(.5px); }

    /* All-toggle button (only in "Все") */
    .all-toggle{
      width:40px;
      height:40px;
      border-radius:var(--r10);
      background:transparent;
      border:1px solid transparent;
      color:var(--muted);
      cursor:pointer;
      display:grid;
      place-items:center;
      transition:color .15s, background .15s, border-color .15s;
      -webkit-tap-highlight-color:var(--tap);
      flex:0 0 auto;
    }
    .all-toggle:hover{ color:var(--text); background:var(--panel); border-color:var(--border); }
    .all-toggle.on{ color:var(--blue); }
    .all-toggle.hidden{ display:none; }

    /* ===== Filter ===== */
    .filter-wrap{
      flex:1 1 auto;
      min-width:0;
      height:40px;
      display:flex;
      align-items:center;
      gap:6px;

      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--r10);
      padding:0 8px;
    }
    .filter-input{
      width:100%;
      border:none;
      outline:none;
      background:transparent;
      color:var(--text);
      font-size:14px;
      min-width:0;
    }
    .filter-input::placeholder{ color:var(--muted); }
    .filter-input:disabled{ opacity:.55; }

    .filter-clear{
      width:28px;
      height:28px;
      border:none;
      border-radius:8px;
      background:transparent;
      color:var(--muted);
      cursor:pointer;
      display:grid;
      place-items:center;
      -webkit-tap-highlight-color:var(--tap);
    }
    .filter-clear:hover{ color:var(--text); background:var(--panel2); }
    .filter-clear.hidden{ display:none; }

    .header-buttons{
      display:flex;
      align-items:center;
      gap:8px;
      flex:0 0 auto;
    }

    .icon-btn{
      width:40px;
      height:40px;
      border-radius:var(--r10);
      background:transparent;
      border:1px solid transparent;
      color:var(--muted);
      cursor:pointer;
      display:grid;
      place-items:center;
      transition:color .15s, background .15s, border-color .15s;
      -webkit-tap-highlight-color:var(--tap);
    }
    .icon-btn:hover{ color:var(--text); background:var(--panel); border-color:var(--border); }
    .icon-btn:active{ transform:translateY(.5px); }
    .icon-btn.error{ color:var(--red); background:var(--panel); border-color:#3d1f22; }

    .icon{ width:18px; height:18px; fill:currentColor; display:block; }
    .icon.small{ width:14px; height:14px; }
    .icon.tiny{ width:12px; height:12px; }

    /* ===== Content ===== */
    .content-area{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--r10);
      min-height:420px;
      overflow:hidden;
    }

    .content-list{
      padding:14px 15px;
      min-height:420px;
      line-height:1.5;
    }

    .content-list:empty::before{
      content:"—";
      color:var(--muted2);
      font-size:32px;
      display:flex;
      justify-content:center;
      padding-top:160px;
    }

    .item-line{
      display:flex;
      align-items:center;
      gap:8px;

      padding:6px 8px;
      margin:0 -8px 8px;
      border-radius:var(--r10);

      background:transparent;
      cursor:default;
      -webkit-tap-highlight-color:var(--tap);

      user-select:text;
      -webkit-user-select:text;
    }
    .item-line:last-child{ margin-bottom:0; }

    .item-line:hover{ background:var(--panel2); }

    .item-line.selected{
      background:var(--border2);
      box-shadow:inset 0 0 0 1px var(--border);
    }

    .item-actions-left{
      display:flex;
      gap:6px;
      align-items:center;
      flex:0 0 auto;

      opacity:0;
      pointer-events:none;
      transition:opacity .12s;
    }
    .item-line.selected .item-actions-left{
      opacity:1;
      pointer-events:auto;
    }

    .mini-action{
      width:30px;
      height:30px;
      border-radius:10px;
      border:1px solid transparent;
      background:transparent;
      color:var(--muted);
      cursor:pointer;
      display:grid;
      place-items:center;
      -webkit-tap-highlight-color:var(--tap);
      transition:color .12s, background .12s, border-color .12s, opacity .12s;
    }
    .mini-action:hover{ color:var(--text); background:#0b0f15; border-color:var(--border); }
    .mini-action.danger:hover{ color:var(--red); border-color:#3d1f22; }

    /* confirm is reserved in layout but hidden unless armed */
    .mini-action.confirm{
      opacity:0;
      pointer-events:none;
      color:#7ee787;
    }
    .item-line.del-armed .mini-action.confirm{
      opacity:1;
      pointer-events:auto;
    }
    .mini-action.confirm:hover{
      color:#7ee787;
      border-color:#1d3b22;
      background:#0f1a12;
    }

    .item-section-tag{
      background:var(--border);
      color:#8b949e;
      font-size:10px;
      padding:1px 6px;
      border-radius:6px;
      white-space:nowrap;
      flex-shrink:0;

      display:flex;
      align-items:center;
      gap:6px;

      user-select:none;
      -webkit-user-select:none;
    }

    .item-text{
      flex:1;
      white-space:pre-wrap;
      word-break:break-word;
      cursor:text;
      user-select:text;
      -webkit-user-select:text;
    }

    /* Right action (mark seen / return) */
    .right-action{
      width:30px;
      height:30px;
      border-radius:10px;
      border:1px solid transparent;
      background:transparent;
      color:var(--muted);
      cursor:pointer;
      display:grid;
      place-items:center;
      flex:0 0 auto;
      -webkit-tap-highlight-color:var(--tap);

      opacity:0;
      pointer-events:none;
      transition:opacity .12s, background .12s, border-color .12s, color .12s;
    }
    .item-line.selected .right-action{
      opacity:1;
      pointer-events:auto;
    }
    .right-action:hover{
      color:var(--text);
      background:#0b0f15;
      border-color:var(--border);
    }

    /* ===== Edit ===== */
    .hidden{ display:none; }

    .edit-hint{
      font-size:11px;
      color:var(--muted);
      padding:8px 15px;
      border-bottom:1px solid var(--border);
      background:var(--panel2);
    }

    .content-edit{
      width:100%;
      min-height:420px;
      border:none;
      background:var(--bg);
      color:var(--text);
      padding:14px 15px;
      font-size:14px;
      font-family:inherit;
      line-height:1.6;
      resize:vertical;
    }
    .content-edit:focus{ outline:none; }

    .edit-panel{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      padding:10px 15px;
      border-top:1px solid var(--border);
      background:var(--panel2);
    }

    .edit-panel button{
      width:42px;
      height:42px;
      border:none;
      border-radius:var(--r10);
      cursor:pointer;
      display:grid;
      place-items:center;
      color:white;
      -webkit-tap-highlight-color:var(--tap);
    }
    .btn-cancel{ background:var(--border); }
    .btn-save{ background:var(--green); }

    .counter{
      text-align:right;
      padding:10px 15px;
      color:var(--muted2);
      font-size:12px;
      border-top:1px solid var(--border);
      background:var(--panel2);
    }

    /* ===== Dropdowns ===== */
    .dropdown-menu{
      position:absolute;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--r10);
      z-index:120;
      overflow:hidden;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }

    .dropdown-menu.section-menu{ padding:8px 0; min-width:260px; }
    .dropdown-menu.sort-menu{ padding:6px 0; width:170px; min-width:170px; }
    .dropdown-menu.settings-menu{ padding:14px; width:260px; min-width:260px; }

    .menu-option{
      padding:8px 14px;
      cursor:pointer;
      font-size:14px;
      display:flex;
      align-items:center;
      gap:10px;
      user-select:none;
      -webkit-tap-highlight-color:var(--tap);
    }
    .menu-option:hover{ background:var(--border2); }
    .menu-option.active{ color:var(--blue); }

    .menu-option.all-sections{
      border-bottom:1px solid var(--border);
      margin-bottom:6px;
      padding-bottom:10px;
    }

    .menu-divider{ border-top:1px solid var(--border); margin:6px 0; }
    .menu-option.add-new{ color:var(--blue); }

    /* delete confirm inline (confirm reserved at left) */
    .menu-actions{
      margin-left:auto;
      display:flex;
      gap:6px;
      align-items:center;
    }

    .mini-btn{
      width:26px;
      height:26px;
      border-radius:8px;
      display:grid;
      place-items:center;
      background:transparent;
      border:1px solid transparent;
      color:var(--muted);
      cursor:pointer;
      -webkit-tap-highlight-color:var(--tap);
      transition:color .12s, background .12s, border-color .12s, opacity .12s;
    }
    .mini-btn:hover{ background:var(--panel2); color:var(--text); border-color:var(--border); }
    .mini-btn.danger:hover{ color:var(--red); border-color:#3d1f22; }

    .mini-btn.confirm{
      opacity:0;
      pointer-events:none;
      color:#7ee787;
    }
    .menu-option.armed .mini-btn.confirm{
      opacity:1;
      pointer-events:auto;
    }
    .mini-btn.confirm:hover{ border-color:#1d3b22; background:#0f1a12; }

    .new-section-input{
      width:calc(100% - 28px);
      margin:8px 14px;
      background:var(--bg);
      border:1px solid var(--border);
      border-radius:var(--r10);
      color:var(--text);
      padding:8px 10px;
      font-size:13px;
    }
    .new-section-input:focus{ outline:none; border-color:var(--blue); }

    .sort-dir{ margin-left:auto; color:#8b949e; font-size:12px; }

    .settings-menu label{
      display:block;
      font-size:11px;
      color:#8b949e;
      margin-bottom:4px;
    }
    .settings-menu input{
      width:100%;
      background:var(--bg);
      border:1px solid var(--border);
      border-radius:var(--r10);
      color:var(--text);
      padding:8px 10px;
      font-size:13px;
      margin-bottom:12px;
    }
    .settings-menu input:focus{ outline:none; border-color:var(--blue); }

    .settings-buttons{ display:flex; gap:8px; }
    .settings-btn{
      flex:1;
      height:42px;
      border:none;
      border-radius:var(--r10);
      cursor:pointer;
      display:grid;
      place-items:center;
      color:white;
      -webkit-tap-highlight-color:var(--tap);
    }
    .btn-primary{ background:var(--green); }
    .btn-share{ background:#1f6feb; }

    .setup-prompt{ padding:16px; color:#8b949e; text-align:center; }

    /* ===== Undo bar ===== */
    .undo-bar{
      position:fixed;
      left:50%;
      bottom:14px;
      transform:translateX(-50%);
      z-index:200;

      display:flex;
      align-items:center;
      gap:10px;

      background:#0b0f15;
      border:1px solid var(--border);
      box-shadow:0 10px 25px rgba(0,0,0,.35);
      border-radius:999px;
      padding:8px 10px 8px 12px;
      max-width:min(92vw, 560px);
    }
    .undo-text{
      color:#8b949e;
      font-size:13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 420px;
    }
    .undo-btn{
      width:34px;
      height:34px;
      border-radius:999px;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      cursor:pointer;
      display:grid;
      place-items:center;
      -webkit-tap-highlight-color:var(--tap);
    }
    .undo-btn:hover{ border-color:var(--blue); }
    .undo-bar.hidden{ display:none; }
  </style>
</head>

<body>
  <!-- Mono SVG icons -->
  <svg aria-hidden="true" style="position:absolute;width:0;height:0;overflow:hidden">
    <symbol id="i-chevron-down" viewBox="0 0 16 16">
      <path d="M4.2 6.2a1 1 0 0 1 1.4 0L8 8.6l2.4-2.4a1 1 0 1 1 1.4 1.4l-3.1 3.1a1 1 0 0 1-1.4 0L4.2 7.6a1 1 0 0 1 0-1.4z"></path>
    </symbol>

    <symbol id="i-sort" viewBox="0 0 16 16">
      <path d="M6 2a1 1 0 0 1 1 1v9.6l1.3-1.3a1 1 0 1 1 1.4 1.4l-3 3a1 1 0 0 1-1.4 0l-3-3a1 1 0 0 1 1.4-1.4L5 12.6V3a1 1 0 0 1 1-1z"></path>
      <path d="M10 14a1 1 0 0 1-1-1V3.4L7.7 4.7a1 1 0 1 1-1.4-1.4l3-3a1 1 0 0 1 1.4 0l3 3a1 1 0 0 1-1.4 1.4L11 3.4V13a1 1 0 0 1-1 1z" opacity=".35"></path>
    </symbol>

    <symbol id="i-pencil" viewBox="0 0 16 16">
      <path d="M12.9 1.7a2 2 0 0 1 2.8 2.8l-9 9L3 14l.5-3.7 9.4-8.6zM4.6 10.9 4.3 13l2.1-.3 8.2-8.2-1.8-1.8-8.2 8.2z"></path>
    </symbol>

    <symbol id="i-x" viewBox="0 0 16 16">
      <path d="M4 4a1 1 0 0 1 1.4 0L8 6.6 10.6 4A1 1 0 1 1 12 5.4L9.4 8 12 10.6A1 1 0 0 1 10.6 12L8 9.4 5.4 12A1 1 0 0 1 4 10.6L6.6 8 4 5.4A1 1 0 0 1 4 4z"></path>
    </symbol>

    <symbol id="i-check" viewBox="0 0 16 16">
      <path d="M6.5 11.2 3.3 8a1 1 0 1 1 1.4-1.4l1.8 1.8 4.8-4.8a1 1 0 1 1 1.4 1.4l-6.2 6.2a1 1 0 0 1-1.4 0z"></path>
    </symbol>

    <symbol id="i-gear" viewBox="0 0 16 16">
      <path d="M9.7 1.2 10 2.6c.3.1.6.3.9.5l1.3-.7 1.1 2-1.1 1c.1.3.2.6.2 1s-.1.7-.2 1l1.1 1-1.1 2-1.3-.7c-.3.2-.6.4-.9.5l-.3 1.4H6.3L6 13.4c-.3-.1-.6-.3-.9-.5l-1.3.7-1.1-2 1.1-1c-.1-.3-.2-.6-.2-1s.1-.7.2-1l-1.1-1 1.1-2 1.3.7c.3-.2.6-.4.9-.5l.3-1.4h3.4zM8 10.5A2.5 2.5 0 1 0 8 5.5a2.5 2.5 0 0 0 0 5z"></path>
    </symbol>

    <symbol id="i-copy" viewBox="0 0 16 16">
      <path d="M5 2.5A2.5 2.5 0 0 1 7.5 0h6A2.5 2.5 0 0 1 16 2.5v6A2.5 2.5 0 0 1 13.5 11h-6A2.5 2.5 0 0 1 5 8.5v-6zM7.5 2A.5.5 0 0 0 7 2.5v6a.5.5 0 0 0 .5.5h6a.5.5 0 0 0 .5-.5v-6a.5.5 0 0 0-.5-.5h-6z"></path>
      <path d="M0 6.5A2.5 2.5 0 0 1 2.5 4H4v2H2.5a.5.5 0 0 0-.5.5v6a.5.5 0 0 0 .5.5h6a.5.5 0 0 0 .5-.5V11h2v1.5A2.5 2.5 0 0 1 8.5 15h-6A2.5 2.5 0 0 1 0 12.5v-6z" opacity=".45"></path>
    </symbol>

    <!-- undo/back arrow -->
    <symbol id="i-undo" viewBox="0 0 16 16">
      <path d="M6.2 4.1a1 1 0 0 1 0 1.4L4.7 7h6.1c2 0 3.7 1.5 3.7 3.5S12.8 14 10.8 14H7a1 1 0 1 1 0-2h3.8c.9 0 1.7-.7 1.7-1.5S11.7 9 10.8 9H4.7l1.5 1.5a1 1 0 1 1-1.4 1.4L1.6 8.7a1 1 0 0 1 0-1.4l3.2-3.2a1 1 0 0 1 1.4 0z"></path>
    </symbol>

    <!-- eye (toggle) -->
    <symbol id="i-eye" viewBox="0 0 16 16">
      <path d="M8 3C3.5 3 1 8 1 8s2.5 5 7 5 7-5 7-5-2.5-5-7-5zm0 8a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"></path>
      <path d="M8 6.5A1.5 1.5 0 1 0 8 9.5a1.5 1.5 0 0 0 0-3z"></path>
    </symbol>
    <symbol id="i-eye-off" viewBox="0 0 16 16">
      <path d="M2 2a1 1 0 0 1 1.4 0l10.6 10.6A1 1 0 1 1 12.6 14L11 12.4C9.9 13 8.8 13.3 8 13.3 3.5 13.3 1 8.3 1 8.3c.6-1.2 1.7-2.8 3.3-3.9L2 2zm4 4 1.1 1.1A1.9 1.9 0 0 0 7 8a1.9 1.9 0 0 0 .9 1.6L9 10.7A3 3 0 0 1 6 6z"></path>
      <path d="M8 3.3c4.5 0 7 5 7 5-.5 1-1.3 2.3-2.5 3.4L10.9 10c.6-.5 1.1-1.1 1.5-1.7 0 0-2.5-3.9-4.4-3.9-.3 0-.6 0-1 .1L5.4 3.9c.8-.4 1.7-.6 2.6-.6z"></path>
    </symbol>

    <!-- "viewed" marker icon (monochrome) -->
    <symbol id="i-eye-done" viewBox="0 0 16 16">
      <path d="M8 3C3.5 3 1 8 1 8s2.5 5 7 5 7-5 7-5-2.5-5-7-5zm0 8a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"></path>
      <path d="M8 6.5A1.5 1.5 0 1 0 8 9.5a1.5 1.5 0 0 0 0-3z"></path>
      <!-- small marker dot (top-right) -->
      <path d="M13.2 3.2a1.2 1.2 0 1 1-2.4 0 1.2 1.2 0 0 1 2.4 0z"></path>
    </symbol>
  </svg>

  <div class="container" id="container">
    <header>
      <div class="header-row">
        <button class="section-btn" id="sectionBtn" onclick="toggleSectionMenu()">
          <span id="currentSectionName">Все</span>
          <svg class="icon small" viewBox="0 0 16 16"><use href="#i-chevron-down"></use></svg>
        </button>

        <!-- toggle only for "Все": include/exclude viewed sections -->
        <button class="all-toggle hidden" id="viewedToggleBtn" onclick="toggleShowViewed()" title="Показывать/скрывать просмотренное">
          <svg class="icon" viewBox="0 0 16 16"><use id="viewedToggleUse" href="#i-eye-off"></use></svg>
        </button>

        <div class="filter-wrap" title="Фильтр">
          <input class="filter-input" id="filterInput" placeholder="Фильтр" autocapitalize="off" autocomplete="off" spellcheck="false" />
          <button class="filter-clear hidden" id="filterClear" title="Очистить фильтр" onclick="clearFilter()">
            <svg class="icon small" viewBox="0 0 16 16"><use href="#i-x"></use></svg>
          </button>
        </div>

        <div class="header-buttons">
          <button class="icon-btn" id="sortBtn" onclick="toggleSort()" title="Сортировка">
            <svg class="icon"><use href="#i-sort"></use></svg>
          </button>

          <button class="icon-btn" id="editBtn" onclick="toggleEdit()" title="Редактировать">
            <svg class="icon"><use id="editUse" href="#i-pencil"></use></svg>
          </button>

          <button class="icon-btn" id="settingsBtn" onclick="toggleSettings()" title="Настройки">
            <svg class="icon"><use href="#i-gear"></use></svg>
          </button>
        </div>
      </div>
    </header>

    <div class="content-area">
      <div class="content-list" id="viewMode"></div>

      <div class="hidden" id="editMode">
        <div class="edit-hint hidden" id="editHint">[Раздел] Текст</div>
        <textarea class="content-edit" id="editor" placeholder="..."></textarea>
        <div class="edit-panel">
          <button class="btn-cancel" onclick="cancelEdit()" title="Отмена">
            <svg class="icon"><use href="#i-x"></use></svg>
          </button>
          <button class="btn-save" onclick="saveEdit()" title="Сохранить">
            <svg class="icon"><use href="#i-check"></use></svg>
          </button>
        </div>
      </div>

      <div class="counter" id="counter"></div>
    </div>

    <!-- Sections -->
    <div class="dropdown-menu section-menu hidden" id="sectionMenu">
      <div class="menu-option all-sections" onclick="selectSection('__all__')">Все</div>
      <div id="sectionList"></div>
      <div class="menu-divider"></div>
      <div class="menu-option add-new" onclick="showNewSectionInput()">+ Новый</div>
      <input
        type="text"
        class="new-section-input hidden"
        id="newSectionInput"
        placeholder="Название..."
        onkeydown="handleNewSection(event)"
      />
    </div>

    <!-- Sort (compact toggle direction) -->
    <div class="dropdown-menu sort-menu hidden" id="sortMenu">
      <div class="menu-option" data-key="manual" onclick="setSortKey('manual')">
        Вручную <span class="sort-dir"></span>
      </div>
      <div class="menu-option" data-key="date" onclick="setSortKey('date')">
        Дата <span class="sort-dir"></span>
      </div>
      <div class="menu-option" data-key="alpha" onclick="setSortKey('alpha')">
        А-Я <span class="sort-dir"></span>
      </div>
      <div class="menu-option" data-key="year" onclick="setSortKey('year')">
        Год <span class="sort-dir"></span>
      </div>
    </div>

    <!-- Settings -->
    <div class="dropdown-menu settings-menu hidden" id="settingsMenu">
      <label>Gist ID</label>
      <input type="text" id="inputGistId" placeholder="abc123..." />

      <label>Token</label>
      <input type="password" id="inputToken" placeholder="ghp_..." />

      <div class="settings-buttons">
        <button class="settings-btn btn-primary" onclick="saveSettings()" title="Применить">
          <svg class="icon"><use href="#i-check"></use></svg>
        </button>
        <button class="settings-btn btn-share" onclick="copyShareLink()" id="shareBtn" title="Скопировать ссылку">
          <svg class="icon"><use href="#i-copy"></use></svg>
        </button>
      </div>
    </div>
  </div>

  <!-- Undo bar -->
  <div class="undo-bar hidden" id="undoBar">
    <div class="undo-text" id="undoText"></div>
    <button class="undo-btn" id="undoBtn" title="Отменить">
      <svg class="icon" viewBox="0 0 16 16"><use href="#i-undo"></use></svg>
    </button>
  </div>

  <script>
    // ===== CONFIG =====
    const VIEWED_KEY_PREFIX = "__viewed__:";     // внутренний префикс (не показываем как текст)
    const OLD_VIEWED_PREFIX = "✓ ";             // миграция со старых данных

    const SECTION_UNDO_MS = 10000;
    const ITEM_UNDO_MS = 19000;

    let GIST_ID = localStorage.getItem("gist_id") || "";
    let TOKEN = localStorage.getItem("github_token") || "";

    let currentSection = localStorage.getItem("current_section") || "__all__";
    let sortState = parseSortState(localStorage.getItem("sort_state")) || { key: "manual", dir: "desc" };

    let filterQuery = localStorage.getItem("filter_query") || "";

    // default: hide viewed in "Все"
    let showViewedInAll = (localStorage.getItem("show_viewed_all") ?? "0") === "1";

    let data = { sections: {} };
    let isEditing = false;

    const defaultSections = ["Фильмы", "Сериалы", "Аниме"];

    // selection highlight
    let selectedKey = null; // `${section}|${index}`

    // pointer/text selection helper
    let pointer = { down:false, startX:0, startY:0, moved:false, startedAt:0 };

    // delete confirmation state for sections
    let deleteArmSection = null;
    let deleteArmTimer = null;

    // delete confirmation state for item
    let deleteArmItemKey = null;
    let deleteArmItemTimer = null;

    // undo state (single slot)
    let undoTimer = null;
    let undoPayload = null; // {type, ...}

    // edit context for filtered editing
    let editCtx = null; // {mode, filterLower, showViewedInAll, masksBySection? / mask? / section?}

    // ===== INIT =====
    async function init() {
      applyUrlSetupSilently();
      updateSettingsIcon();
      updateShareButton();
      setupFilterUI();
      updateViewedToggleUI();

      if (!GIST_ID || !TOKEN) {
        document.getElementById("viewMode").innerHTML = `<div class="setup-prompt">Откройте настройки</div>`;
        document.getElementById("counter").textContent = "";
        return;
      }

      await loadData();
      ensureDefaultSections();
      migrateViewedPrefixesIfNeeded();
      renderSectionList();
      updateSectionButton();
      render();
    }

    // ===== URL SETUP (silent) =====
    function applyUrlSetupSilently() {
      const params = new URLSearchParams(window.location.search);
      const setup = params.get("s");
      if (!setup) return;

      try {
        const decoded = atob(setup);
        const [gist, token] = decoded.split(":");
        if (gist && token) {
          localStorage.setItem("gist_id", gist);
          localStorage.setItem("github_token", token);
          GIST_ID = gist;
          TOKEN = token;
          window.history.replaceState({}, "", window.location.pathname);
        }
      } catch (_) {}
    }

    // ===== Viewed helpers =====
    function isViewedSection(name) {
      return typeof name === "string" && (name.startsWith(VIEWED_KEY_PREFIX) || name.startsWith(OLD_VIEWED_PREFIX));
    }

    function baseSectionName(name) {
      if (typeof name !== "string") return "";
      if (name.startsWith(VIEWED_KEY_PREFIX)) return name.slice(VIEWED_KEY_PREFIX.length);
      if (name.startsWith(OLD_VIEWED_PREFIX)) return name.slice(OLD_VIEWED_PREFIX.length);
      return name;
    }

    function viewedSectionKeyFor(sourceSectionName) {
      return VIEWED_KEY_PREFIX + baseSectionName(sourceSectionName);
    }

    function labelHTMLForSection(name) {
      const base = escapeHtml(baseSectionName(name));
      if (!isViewedSection(name)) return base;
      return `<svg class="icon tiny" viewBox="0 0 16 16"><use href="#i-eye-done"></use></svg>${base}`;
    }

    function migrateViewedPrefixesIfNeeded() {
      // rename keys "✓ X" -> "__viewed__:X"
      const keys = Object.keys(data.sections || {});
      const toRename = keys.filter(k => k.startsWith(OLD_VIEWED_PREFIX));
      if (!toRename.length) return;

      for (const oldKey of toRename) {
        const base = oldKey.slice(OLD_VIEWED_PREFIX.length);
        const newKey = VIEWED_KEY_PREFIX + base;

        if (!data.sections[newKey]) {
          data.sections[newKey] = data.sections[oldKey];
          delete data.sections[oldKey];
        } else {
          // merge items if both exist
          const a = data.sections[newKey]?.items || [];
          const b = data.sections[oldKey]?.items || [];
          data.sections[newKey].items = [...a, ...b];
          delete data.sections[oldKey];
        }

        // fix currentSection if needed
        if (currentSection === oldKey) {
          currentSection = newKey;
          localStorage.setItem("current_section", newKey);
        }
      }

      // persist migration
      saveData();
    }

    // ===== Filter =====
    function setupFilterUI() {
      const input = document.getElementById("filterInput");
      const clear = document.getElementById("filterClear");

      input.value = filterQuery;
      clear.classList.toggle("hidden", !filterQuery);

      input.oninput = () => {
        if (isEditing) return;
        filterQuery = input.value || "";
        localStorage.setItem("filter_query", filterQuery);
        clear.classList.toggle("hidden", !filterQuery);
        selectedKey = null;
        disarmItemDelete();
        render();
      };

      input.onkeydown = (e) => {
        if (e.key === "Escape") {
          clearFilter();
          input.blur();
        }
      };
    }

    function setFilterLock(locked) {
      const input = document.getElementById("filterInput");
      const clear = document.getElementById("filterClear");
      input.disabled = locked;
      if (locked) clear.classList.add("hidden");
      else clear.classList.toggle("hidden", !filterQuery);
    }

    function clearFilter() {
      if (isEditing) return;
      filterQuery = "";
      localStorage.setItem("filter_query", "");
      const input = document.getElementById("filterInput");
      input.value = "";
      document.getElementById("filterClear").classList.add("hidden");
      selectedKey = null;
      disarmItemDelete();
      render();
      input.focus();
    }

    // ===== Viewed toggle in "All" =====
    function updateViewedToggleUI() {
      const btn = document.getElementById("viewedToggleBtn");
      const use = document.getElementById("viewedToggleUse");

      btn.classList.toggle("hidden", currentSection !== "__all__");
      btn.classList.toggle("on", showViewedInAll);
      use.setAttribute("href", showViewedInAll ? "#i-eye" : "#i-eye-off");
    }

    function toggleShowViewed() {
      if (isEditing) return;
      showViewedInAll = !showViewedInAll;
      localStorage.setItem("show_viewed_all", showViewedInAll ? "1" : "0");
      selectedKey = null;
      disarmItemDelete();
      updateViewedToggleUI();
      render();
    }

    // ===== Menu positioning =====
    function openMenu(menuId, anchorEl, align = "left") {
      closeAllMenus(menuId);

      const menu = document.getElementById(menuId);
      const container = document.getElementById("container");

      menu.classList.remove("hidden");
      menu.style.visibility = "hidden";

      const cRect = container.getBoundingClientRect();
      const aRect = anchorEl.getBoundingClientRect();
      const mRect = menu.getBoundingClientRect();

      const top = aRect.bottom - cRect.top + 8;
      let left = (align === "right")
        ? aRect.right - cRect.left - mRect.width
        : aRect.left - cRect.left;

      left = Math.max(0, Math.min(left, cRect.width - mRect.width));

      menu.style.top = `${top}px`;
      menu.style.left = `${left}px`;
      menu.style.visibility = "visible";
    }

    // ===== SETTINGS =====
    function toggleSettings() {
      if (isEditing) return;

      const menu = document.getElementById("settingsMenu");
      const btn = document.getElementById("settingsBtn");

      if (!menu.classList.contains("hidden")) {
        menu.classList.add("hidden");
        return;
      }

      document.getElementById("inputGistId").value = GIST_ID;
      document.getElementById("inputToken").value = TOKEN;
      updateShareButton();
      openMenu("settingsMenu", btn, "right");
    }

    function saveSettings() {
      const gistId = document.getElementById("inputGistId").value.trim();
      const token = document.getElementById("inputToken").value.trim();
      if (!gistId || !token) return;

      localStorage.setItem("gist_id", gistId);
      localStorage.setItem("github_token", token);
      GIST_ID = gistId;
      TOKEN = token;

      document.getElementById("settingsMenu").classList.add("hidden");
      updateSettingsIcon();
      updateShareButton();
      init();
    }

    function updateSettingsIcon() {
      document.getElementById("settingsBtn").classList.toggle("error", !GIST_ID || !TOKEN);
    }

    function updateShareButton() {
      document.getElementById("shareBtn").style.display = (GIST_ID && TOKEN) ? "grid" : "none";
    }

    function copyShareLink() {
      if (!GIST_ID || !TOKEN) return;
      const link = `${location.origin}${location.pathname}?s=${btoa(`${GIST_ID}:${TOKEN}`)}`;
      if (navigator.clipboard) navigator.clipboard.writeText(link);
      else {
        const ta = document.createElement("textarea");
        ta.value = link;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
      }
    }

    // ===== SECTIONS =====
    function toggleSectionMenu() {
      if (isEditing) return;

      const menu = document.getElementById("sectionMenu");
      const btn = document.getElementById("sectionBtn");

      if (!menu.classList.contains("hidden")) {
        menu.classList.add("hidden");
        document.getElementById("newSectionInput").classList.add("hidden");
        disarmSectionDelete();
        return;
      }

      renderSectionList();
      document.getElementById("newSectionInput").classList.add("hidden");
      openMenu("sectionMenu", btn, "left");
    }

    function ensureDefaultSections() {
      if (Object.keys(data.sections).length) return;
      defaultSections.forEach((s) => (data.sections[s] = { items: [], modified: new Date().toISOString() }));
    }

    function renderSectionList() {
      const list = document.getElementById("sectionList");
      const keys = Object.keys(data.sections);

      list.innerHTML = keys.map((name) => {
        const armed = (deleteArmSection === name);
        return `
          <div class="menu-option ${currentSection === name ? "active" : ""} ${armed ? "armed" : ""}"
               onclick="selectSection('${escapeQuotes(name)}')">
            <span style="display:flex;align-items:center;gap:8px;">
              ${labelHTMLForSection(name)}
            </span>

            <span class="menu-actions" onclick="event.stopPropagation()">
              <button class="mini-btn confirm" title="Подтвердить" onclick="confirmDeleteSection('${escapeQuotes(name)}')">
                ✓
              </button>
              <button class="mini-btn danger" title="Удалить" onclick="armDeleteSection('${escapeQuotes(name)}')">
                ×
              </button>
            </span>
          </div>
        `;
      }).join("");
    }

    function selectSection(name) {
      currentSection = name;
      localStorage.setItem("current_section", name);
      selectedKey = null;
      disarmItemDelete();
      disarmSectionDelete();
      updateSectionButton();
      updateViewedToggleUI();
      document.getElementById("sectionMenu").classList.add("hidden");
      render();
    }

    function updateSectionButton() {
      const el = document.getElementById("currentSectionName");
      if (currentSection === "__all__") {
        el.textContent = "Все";
        return;
      }
      el.innerHTML = labelHTMLForSection(currentSection);
    }

    function showNewSectionInput() {
      const input = document.getElementById("newSectionInput");
      input.classList.remove("hidden");
      input.value = "";
      input.focus();
      disarmSectionDelete();
    }

    function handleNewSection(e) {
      if (e.key === "Enter") {
        const name = e.target.value.trim();
        if (name && !data.sections[name]) {
          data.sections[name] = { items: [], modified: new Date().toISOString() };
          saveData();
          renderSectionList();
          selectSection(name);
        }
        e.target.classList.add("hidden");
      } else if (e.key === "Escape") {
        e.target.classList.add("hidden");
      }
    }

    // ===== Section delete confirm + undo =====
    function armDeleteSection(name) {
      if (Object.keys(data.sections).length <= 1) return;

      if (deleteArmSection === name) {
        disarmSectionDelete();
        renderSectionList();
        return;
      }

      deleteArmSection = name;
      renderSectionList();

      if (deleteArmTimer) clearTimeout(deleteArmTimer);
      deleteArmTimer = setTimeout(() => {
        disarmSectionDelete();
        renderSectionList();
      }, 6000);
    }

    function disarmSectionDelete() {
      deleteArmSection = null;
      if (deleteArmTimer) clearTimeout(deleteArmTimer);
      deleteArmTimer = null;
    }

    function confirmDeleteSection(name) {
      if (Object.keys(data.sections).length <= 1) return;
      if (!data.sections[name]) return;
      if (deleteArmSection !== name) return;

      disarmSectionDelete();

      const payload = {
        type: "section",
        name,
        sectionData: JSON.parse(JSON.stringify(data.sections[name])),
        prevCurrentSection: currentSection
      };

      delete data.sections[name];

      if (currentSection === name) {
        currentSection = "__all__";
        localStorage.setItem("current_section", "__all__");
        updateSectionButton();
        updateViewedToggleUI();
      }

      selectedKey = null;
      disarmItemDelete();

      saveData();
      renderSectionList();
      render();

      startUndo(payload, SECTION_UNDO_MS, `Раздел удалён: ${baseSectionName(name)}`);
    }

    // ===== SORT (compact toggle direction) =====
    function toggleSort() {
      if (isEditing) return;

      const menu = document.getElementById("sortMenu");
      const btn = document.getElementById("sortBtn");

      if (!menu.classList.contains("hidden")) {
        menu.classList.add("hidden");
        return;
      }

      openMenu("sortMenu", btn, "right");
      updateSortMenuUI();
    }

    function setSortKey(key) {
      if (key === "manual") {
        sortState = { key: "manual", dir: "desc" };
      } else if (sortState.key === key) {
        sortState.dir = (sortState.dir === "asc") ? "desc" : "asc";
      } else {
        sortState = { key, dir: defaultDirForKey(key) };
      }

      localStorage.setItem("sort_state", `${sortState.key}:${sortState.dir}`);
      selectedKey = null;
      disarmItemDelete();
      updateSortMenuUI();
      document.getElementById("sortMenu").classList.add("hidden");
      render();
    }

    function defaultDirForKey(key) {
      if (key === "alpha") return "asc";
      return "desc";
    }

    function updateSortMenuUI() {
      document.querySelectorAll("#sortMenu .menu-option").forEach((el) => {
        const key = el.dataset.key;
        const dirSpan = el.querySelector(".sort-dir");
        const active = (key === sortState.key);
        el.classList.toggle("active", active);

        if (!dirSpan) return;
        if (!active || key === "manual") dirSpan.textContent = "";
        else dirSpan.textContent = (sortState.dir === "asc") ? "↑" : "↓";
      });
    }

    function parseSortState(str) {
      if (!str) return null;
      const [key, dir] = String(str).split(":");
      if (!key) return null;
      return { key, dir: dir === "asc" ? "asc" : "desc" };
    }

    function getSortedItems(items) {
      if (!items || sortState.key === "manual") return items;

      const sorted = [...items];
      const getText = (x) => (x.text ?? x);

      switch (sortState.key) {
        case "alpha":
          sorted.sort((a, b) => getText(a).localeCompare(getText(b), "ru"));
          if (sortState.dir === "desc") sorted.reverse();
          break;

        case "year":
          sorted.sort((a, b) => {
            const yA = (getText(a).match(/\((\d{4})\)/) || [, 0])[1];
            const yB = (getText(b).match(/\((\d{4})\)/) || [, 0])[1];
            return Number(yA) - Number(yB);
          });
          if (sortState.dir === "desc") sorted.reverse();
          break;

        case "date":
          if (sortState.dir === "desc") sorted.reverse();
          break;
      }

      return sorted;
    }

    // ===== API =====
    async function loadData() {
      try {
        const res = await fetch(`https://api.github.com/gists/${GIST_ID}`, {
          headers: { Authorization: `token ${TOKEN}` },
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        const gist = await res.json();
        if (gist.files?.["contents.json"]) {
          const loaded = JSON.parse(gist.files["contents.json"].content);
          if (loaded.users && !loaded.sections) data.sections = loaded.users; // migration old schema
          else data = loaded.sections ? loaded : { sections: {} };
        } else {
          data = { sections: {} };
          await saveData();
        }
      } catch (e) {
        console.error(e);
        data = { sections: {} };
      }
    }

    async function saveData() {
      if (!TOKEN || !GIST_ID) return;
      try {
        await fetch(`https://api.github.com/gists/${GIST_ID}`, {
          method: "PATCH",
          headers: {
            Authorization: `token ${TOKEN}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            files: { "contents.json": { content: JSON.stringify(data, null, 2) } },
          }),
        });
      } catch (e) {
        console.error(e);
      }
    }

    // ===== ITEM actions: move / return / delete =====
    function moveItemToViewed(sectionKey, index) {
      if (!data.sections[sectionKey]) return;
      if (isViewedSection(sectionKey)) return;

      const srcItems = data.sections[sectionKey].items || [];
      const idx = Number(index);
      if (!Number.isFinite(idx) || idx < 0 || idx >= srcItems.length) return;

      const itemText = srcItems[idx];
      srcItems.splice(idx, 1);
      data.sections[sectionKey].modified = new Date().toISOString();

      const destKey = viewedSectionKeyFor(sectionKey);
      if (!data.sections[destKey]) data.sections[destKey] = { items: [], modified: new Date().toISOString() };
      data.sections[destKey].items.push(itemText);
      data.sections[destKey].modified = new Date().toISOString();

      selectedKey = null;
      disarmItemDelete();
      saveData();
      renderSectionList();
      render();
    }

    function returnItemFromViewed(viewedSectionKey, index) {
      if (!data.sections[viewedSectionKey]) return;
      if (!isViewedSection(viewedSectionKey)) return;

      const srcItems = data.sections[viewedSectionKey].items || [];
      const idx = Number(index);
      if (!Number.isFinite(idx) || idx < 0 || idx >= srcItems.length) return;

      const itemText = srcItems[idx];
      srcItems.splice(idx, 1);
      data.sections[viewedSectionKey].modified = new Date().toISOString();

      const baseKey = baseSectionName(viewedSectionKey);
      if (!data.sections[baseKey]) data.sections[baseKey] = { items: [], modified: new Date().toISOString() };
      data.sections[baseKey].items.push(itemText);
      data.sections[baseKey].modified = new Date().toISOString();

      selectedKey = null;
      disarmItemDelete();
      saveData();
      renderSectionList();
      render();
    }

    function armItemDelete(key) {
      if (!key) return;
      deleteArmItemKey = key;

      if (deleteArmItemTimer) clearTimeout(deleteArmItemTimer);
      deleteArmItemTimer = setTimeout(() => {
        disarmItemDelete();
        // remove class without full rerender:
        document.querySelectorAll("#viewMode .item-line.del-armed").forEach(el => el.classList.remove("del-armed"));
      }, 6000);

      // apply class to selected line
      document.querySelectorAll("#viewMode .item-line").forEach(el => {
        el.classList.toggle("del-armed", el.dataset.key === key);
      });
    }

    function disarmItemDelete() {
      deleteArmItemKey = null;
      if (deleteArmItemTimer) clearTimeout(deleteArmItemTimer);
      deleteArmItemTimer = null;
      document.querySelectorAll("#viewMode .item-line.del-armed").forEach(el => el.classList.remove("del-armed"));
    }

    function confirmItemDelete(sectionKey, index) {
      const key = `${sectionKey}|${index}`;
      if (deleteArmItemKey !== key) return;

      const arr = data.sections[sectionKey]?.items;
      if (!arr) return;

      const idx = Number(index);
      if (!Number.isFinite(idx) || idx < 0 || idx >= arr.length) return;

      const text = arr[idx];

      // remove
      arr.splice(idx, 1);
      data.sections[sectionKey].modified = new Date().toISOString();

      disarmItemDelete();
      selectedKey = null;

      saveData();
      render();

      startUndo(
        { type: "item", sectionKey, index: idx, text },
        ITEM_UNDO_MS,
        `Запись удалена`
      );
    }

    // ===== Undo (single slot) =====
    function startUndo(payload, ms, label) {
      undoPayload = payload;

      if (undoTimer) clearTimeout(undoTimer);
      undoTimer = setTimeout(() => {
        hideUndo();
        undoPayload = null;
        undoTimer = null;
      }, ms);

      document.getElementById("undoText").textContent = label;
      document.getElementById("undoBar").classList.remove("hidden");
    }

    function hideUndo() {
      document.getElementById("undoBar").classList.add("hidden");
    }

    document.getElementById("undoBtn").addEventListener("click", () => {
      if (!undoPayload) return;

      if (undoPayload.type === "section") {
        let restoreKey = undoPayload.name;

        // avoid overwrite if recreated
        if (data.sections[restoreKey]) {
          let i = 2;
          while (data.sections[`${restoreKey} (${i})`]) i++;
          restoreKey = `${restoreKey} (${i})`;
        }

        data.sections[restoreKey] = undoPayload.sectionData;

        if (undoPayload.prevCurrentSection === undoPayload.name) {
          currentSection = restoreKey;
          localStorage.setItem("current_section", restoreKey);
          updateSectionButton();
          updateViewedToggleUI();
        }

        saveData();
        renderSectionList();
        render();
      }

      if (undoPayload.type === "item") {
        const { sectionKey, index, text } = undoPayload;
        if (!data.sections[sectionKey]) data.sections[sectionKey] = { items: [], modified: new Date().toISOString() };

        const arr = data.sections[sectionKey].items || (data.sections[sectionKey].items = []);
        const idx = Math.max(0, Math.min(Number(index), arr.length));
        arr.splice(idx, 0, text);
        data.sections[sectionKey].modified = new Date().toISOString();

        saveData();
        render();
      }

      if (undoTimer) clearTimeout(undoTimer);
      undoTimer = null;
      undoPayload = null;
      hideUndo();
    });

    // ===== EDIT (filtered editing supported, like before) =====
    function toggleEdit() {
      if (!TOKEN || !GIST_ID) {
        toggleSettings();
        return;
      }
      isEditing ? cancelEdit() : startEdit();
    }

    function startEdit() {
      isEditing = true;
      selectedKey = null;
      disarmItemDelete();

      setFilterLock(true);

      const editor = document.getElementById("editor");
      const hint = document.getElementById("editHint");
      document.getElementById("editUse").setAttribute("href", "#i-x");

      const filterLower = (filterQuery || "").trim().toLowerCase();

      if (currentSection === "__all__") {
        const masksBySection = {};
        const lines = [];

        for (const sectionKey of Object.keys(data.sections)) {
          if (!showViewedInAll && isViewedSection(sectionKey)) continue;

          const items = data.sections[sectionKey]?.items || [];
          const mask = items.map(it => !filterLower || String(it).toLowerCase().includes(filterLower));

          if (mask.some(Boolean)) masksBySection[sectionKey] = mask;

          for (let i = 0; i < items.length; i++) {
            if (mask[i]) lines.push(`[${sectionKey}] ${items[i]}`);
          }
        }

        editor.value = lines.join("\n");
        hint.classList.remove("hidden");
        editCtx = { mode: "all", filterLower, showViewedInAll, masksBySection };

      } else {
        const sectionKey = currentSection;
        const orig = data.sections[sectionKey]?.items || [];
        const mask = orig.map(it => !filterLower || String(it).toLowerCase().includes(filterLower));
        const lines = orig.filter((_, i) => mask[i]);

        editor.value = lines.join("\n");
        hint.classList.add("hidden");
        editCtx = { mode: "section", sectionKey, filterLower, mask };
      }

      document.getElementById("viewMode").classList.add("hidden");
      document.getElementById("editMode").classList.remove("hidden");
      editor.focus();
    }

    function cancelEdit() {
      isEditing = false;
      editCtx = null;

      setFilterLock(false);

      document.getElementById("viewMode").classList.remove("hidden");
      document.getElementById("editMode").classList.add("hidden");
      document.getElementById("editHint").classList.add("hidden");
      document.getElementById("editUse").setAttribute("href", "#i-pencil");
    }

    function mergeByMask(original, mask, replacement) {
      const out = [];
      let ri = 0;
      const m = Array.isArray(mask) ? mask : new Array(original.length).fill(false);

      for (let i = 0; i < original.length; i++) {
        if (m[i]) {
          if (ri < replacement.length) out.push(replacement[ri++]);
          // else delete matched item
        } else out.push(original[i]);
      }
      while (ri < replacement.length) out.push(replacement[ri++]); // new items appended
      return out;
    }

    function parseAllEditorLines(lines) {
      const bySection = {};
      let lastSection = Object.keys(data.sections)[0] || "Раздел";

      for (const line of lines) {
        const m = line.match(/^\[([^\]]+)\]\s*(.*)$/);
        if (m) {
          const section = m[1].trim();
          const item = (m[2] || "").trim();
          if (!section) continue;
          if (!bySection[section]) bySection[section] = [];
          if (item) bySection[section].push(item);
          lastSection = section;
        } else {
          const item = line.trim();
          if (!item) continue;
          if (!bySection[lastSection]) bySection[lastSection] = [];
          bySection[lastSection].push(item);
        }
      }
      return { bySection };
    }

    async function saveEdit() {
      const text = document.getElementById("editor").value;
      const lines = text.split("\n").map(s => s.trim()).filter(Boolean);

      if (!editCtx) return;

      if (editCtx.mode === "section") {
        const sectionKey = editCtx.sectionKey;
        const orig = data.sections[sectionKey]?.items || [];
        const merged = mergeByMask(orig, editCtx.mask, lines);

        data.sections[sectionKey] = { items: merged, modified: new Date().toISOString() };
      }

      if (editCtx.mode === "all") {
        const parsed = parseAllEditorLines(lines);
        const newBySection = parsed.bySection;

        const allSections = new Set([...Object.keys(data.sections), ...Object.keys(newBySection)]);

        for (const sectionKey of allSections) {
          const orig = data.sections[sectionKey]?.items || [];
          const mask = editCtx.masksBySection[sectionKey] || new Array(orig.length).fill(false);
          const replacement = newBySection[sectionKey] || [];
          const merged = mergeByMask(orig, mask, replacement);

          if (!data.sections[sectionKey]) data.sections[sectionKey] = { items: [], modified: new Date().toISOString() };
          data.sections[sectionKey].items = merged;
          data.sections[sectionKey].modified = new Date().toISOString();
        }
      }

      await saveData();
      renderSectionList();
      cancelEdit();
      render();
    }

    // ===== RENDER =====
    function shouldIncludeSectionInAll(sectionKey) {
      if (currentSection !== "__all__") return true;
      if (showViewedInAll) return true;
      return !isViewedSection(sectionKey);
    }

    function applyFilter(items) {
      const q = (filterQuery || "").trim().toLowerCase();
      if (!q) return items;
      return items.filter(it => String(it.text || "").toLowerCase().includes(q));
    }

    function buildItemsForView() {
      let items = [];
      if (currentSection === "__all__") {
        for (const sectionKey of Object.keys(data.sections)) {
          if (!shouldIncludeSectionInAll(sectionKey)) continue;
          const arr = data.sections[sectionKey]?.items || [];
          for (let i = 0; i < arr.length; i++) {
            items.push({ text: arr[i], sectionKey, index: i });
          }
        }
      } else {
        const arr = (data.sections[currentSection]?.items || []);
        for (let i = 0; i < arr.length; i++) {
          items.push({ text: arr[i], sectionKey: currentSection, index: i });
        }
      }
      items = applyFilter(items);
      items = getSortedItems(items);
      return items;
    }

    function render() {
      const view = document.getElementById("viewMode");
      const items = buildItemsForView();

      if (!items.length) {
        view.innerHTML = "";
        document.getElementById("counter").textContent = "0";
        return;
      }

      // drop selection if it no longer exists
      const keySet = new Set(items.map(it => `${it.sectionKey}|${it.index}`));
      if (selectedKey && !keySet.has(selectedKey)) {
        selectedKey = null;
        disarmItemDelete();
      }

      view.innerHTML = items.map((it) => {
        const key = `${it.sectionKey}|${it.index}`;
        const selected = selectedKey === key;
        const armed = deleteArmItemKey === key;

        const secTag = (currentSection === "__all__")
          ? `<span class="item-section-tag">
               ${isViewedSection(it.sectionKey) ? `<svg class="icon tiny" viewBox="0 0 16 16"><use href="#i-eye-done"></use></svg>` : ``}
               ${escapeHtml(baseSectionName(it.sectionKey))}
             </span>`
          : "";

        // right button logic:
        // - if viewed section => return (undo icon)
        // - else => mark as viewed (eye-done icon)
        const viewed = isViewedSection(it.sectionKey);
        const rightAction = viewed
          ? `<button class="right-action" data-action="back" title="Вернуть из просмотренного">
               <svg class="icon" viewBox="0 0 16 16"><use href="#i-undo"></use></svg>
             </button>`
          : `<button class="right-action" data-action="mark" title="Переместить в просмотренное">
               <svg class="icon" viewBox="0 0 16 16"><use href="#i-eye-done"></use></svg>
             </button>`;

        return `
          <div class="item-line ${selected ? "selected" : ""} ${armed ? "del-armed" : ""}"
               data-key="${escapeAttr(key)}"
               data-section="${escapeAttr(it.sectionKey)}"
               data-index="${String(it.index)}">
            <span class="item-actions-left">
              <button class="mini-action confirm" data-action="item-del-confirm" title="Подтвердить удаление">
                <svg class="icon small" viewBox="0 0 16 16"><use href="#i-check"></use></svg>
              </button>
              <button class="mini-action danger" data-action="item-del" title="Удалить">
                <svg class="icon small" viewBox="0 0 16 16"><use href="#i-x"></use></svg>
              </button>
            </span>

            ${secTag}
            <span class="item-text">${escapeHtml(it.text)}</span>

            ${rightAction}
          </div>
        `;
      }).join("");

      document.getElementById("counter").textContent = String(items.length);
    }

    // ===== View mode: selection + actions =====
    const viewModeEl = document.getElementById("viewMode");

    viewModeEl.addEventListener("pointerdown", (e) => {
      if (isEditing) return;
      pointer.down = true;
      pointer.moved = false;
      pointer.startX = e.clientX;
      pointer.startY = e.clientY;
      pointer.startedAt = Date.now();
    });

    viewModeEl.addEventListener("pointermove", (e) => {
      if (!pointer.down) return;
      if (Math.hypot(e.clientX - pointer.startX, e.clientY - pointer.startY) > 10) pointer.moved = true;
    });

    viewModeEl.addEventListener("pointerup", () => { pointer.down = false; });

    viewModeEl.addEventListener("click", (e) => {
      if (isEditing) return;

      const line = e.target.closest(".item-line");
      if (!line) return;

      const actionEl = e.target.closest("[data-action]");
      if (actionEl) {
        const action = actionEl.dataset.action;
        const sectionKey = line.dataset.section;
        const index = line.dataset.index;
        const key = line.dataset.key;

        e.stopPropagation();

        if (action === "mark") {
          moveItemToViewed(sectionKey, index);
          return;
        }
        if (action === "back") {
          returnItemFromViewed(sectionKey, index);
          return;
        }
        if (action === "item-del") {
          // arm delete only for currently selected row; if not selected, select first
          if (selectedKey !== key) {
            selectedKey = key;
            disarmItemDelete();
            render();
            // after render, arm
            armItemDelete(key);
          } else {
            armItemDelete(key);
          }
          return;
        }
        if (action === "item-del-confirm") {
          confirmItemDelete(sectionKey, index);
          return;
        }
      }

      // if user selected text - don't toggle selection
      const sel = window.getSelection ? window.getSelection() : null;
      if (sel && !sel.isCollapsed) return;

      // ignore long press & drag/scroll gestures
      const longPress = pointer.startedAt && (Date.now() - pointer.startedAt > 350);
      if (longPress) return;
      if (pointer.moved) return;

      const key = line.dataset.key;
      const nowSelected = (selectedKey !== key);

      selectedKey = nowSelected ? key : null;
      disarmItemDelete();

      document.querySelectorAll("#viewMode .item-line.selected").forEach(el => el.classList.remove("selected"));
      if (selectedKey) line.classList.add("selected");
    });

    // ===== Close menus =====
    function closeAllMenus(except) {
      ["sortMenu", "settingsMenu", "sectionMenu"].forEach((id) => {
        if (id !== except) document.getElementById(id).classList.add("hidden");
      });
    }

    document.addEventListener("click", (e) => {
      if (!e.target.closest(".dropdown-menu") &&
          !e.target.closest(".icon-btn") &&
          !e.target.closest(".section-btn") &&
          !e.target.closest(".all-toggle")) {
        closeAllMenus();
        disarmSectionDelete();
        renderSectionList();
      }
    });

    window.addEventListener("scroll", () => {
      closeAllMenus();
      disarmSectionDelete();
    }, { passive: true });

    // ===== Utils =====
    function escapeHtml(str) {
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }
    function escapeAttr(str) { return escapeHtml(str).replaceAll("`", "&#096;"); }
    function escapeQuotes(str) { return String(str).replaceAll("\\", "\\\\").replaceAll("'", "\\'"); }

    init();
  </script>
</body>
</html>
