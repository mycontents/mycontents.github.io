<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Contents</title>

  <style>
    :root{
      --bg:#0d1117;
      --panel:#161b22;
      --panel2:#0f141b;
      --border:#30363d;
      --border2:#21262d;

      --text:#c9d1d9;
      --muted:#6e7681;
      --muted2:#484f58;

      --blue:#58a6ff;
      --red:#f85149;
      --green:#238636;

      --r10:10px;
      --tap:transparent;
    }

    *{ box-sizing:border-box; margin:0; padding:0; }

    body{
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:var(--bg);
      color:var(--text);
      min-height:100vh;
      padding:16px;
    }

    .container{ max-width:800px; margin:0 auto; position:relative; }

    /* ===== Sticky header ===== */
    header{
      position:sticky;
      top:0;
      z-index:100;
      background:var(--bg);
      padding:10px 0;
      border-bottom:1px solid var(--border2);
      margin-bottom:12px;
    }

    .header-row{
      display:flex;
      align-items:center;
      gap:10px;
    }

    .section-btn{
      height:40px;
      min-width:170px;
      padding:0 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;

      background:var(--border2);
      color:var(--text);
      border:1px solid var(--border);
      border-radius:var(--r10);
      cursor:pointer;
      -webkit-tap-highlight-color:var(--tap);
      flex:0 0 auto;
    }
    .section-btn:hover{ border-color:var(--blue); }
    .section-btn:active{ transform:translateY(.5px); }

    /* All-toggle button (only in "Все") */
    .all-toggle{
      width:40px;
      height:40px;
      border-radius:var(--r10);
      background:transparent;
      border:1px solid transparent;
      color:var(--muted);
      cursor:pointer;
      display:grid;
      place-items:center;
      transition:color .15s, background .15s, border-color .15s;
      -webkit-tap-highlight-color:var(--tap);
      flex:0 0 auto;
    }
    .all-toggle:hover{ color:var(--text); background:var(--panel); border-color:var(--border); }
    .all-toggle.on{ color:var(--blue); }
    .all-toggle.hidden{ display:none; }

    /* ===== Filter ===== */
    .filter-wrap{
      flex:1 1 auto;
      min-width:0;
      height:40px;
      display:flex;
      align-items:center;
      gap:6px;

      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--r10);
      padding:0 8px;
    }
    .filter-input{
      width:100%;
      border:none;
      outline:none;
      background:transparent;
      color:var(--text);
      font-size:14px;
      min-width:0;
    }
    .filter-input::placeholder{ color:var(--muted); }
    .filter-input:disabled{ opacity:.55; }

    .filter-clear{
      width:28px;
      height:28px;
      border:none;
      border-radius:8px;
      background:transparent;
      color:var(--muted);
      cursor:pointer;
      display:grid;
      place-items:center;
      -webkit-tap-highlight-color:var(--tap);
    }
    .filter-clear:hover{ color:var(--text); background:var(--panel2); }
    .filter-clear.hidden{ display:none; }

    .header-buttons{
      display:flex;
      align-items:center;
      gap:8px;
      flex:0 0 auto;
    }

    .icon-btn{
      width:40px;
      height:40px;
      border-radius:var(--r10);
      background:transparent;
      border:1px solid transparent;
      color:var(--muted);
      cursor:pointer;
      display:grid;
      place-items:center;
      transition:color .15s, background .15s, border-color .15s;
      -webkit-tap-highlight-color:var(--tap);
    }
    .icon-btn:hover{ color:var(--text); background:var(--panel); border-color:var(--border); }
    .icon-btn:active{ transform:translateY(.5px); }
    .icon-btn.error{ color:var(--red); background:var(--panel); border-color:#3d1f22; }

    .icon{ width:18px; height:18px; fill:currentColor; display:block; }
    .icon.small{ width:14px; height:14px; }

    /* ===== Content ===== */
    .content-area{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--r10);
      min-height:420px;
      overflow:hidden;
    }

    .content-list{
      padding:14px 15px;
      min-height:420px;
      line-height:1.5; /* "как было тогда во Все" (свободнее) */
    }

    .content-list:empty::before{
      content:"—";
      color:var(--muted2);
      font-size:32px;
      display:flex;
      justify-content:center;
      padding-top:160px;
    }

    /* Позиции — увеличили расстояние между строками */
    .item-line{
      display:flex;
      align-items:center;
      gap:8px;

      padding:6px 8px;
      margin:0 -8px 8px; /* ВОТ где основное расстояние между строками */
      border-radius:var(--r10);

      background:transparent;
      cursor:default;
      -webkit-tap-highlight-color:var(--tap);

      user-select:text;
      -webkit-user-select:text;
    }
    .item-line:last-child{ margin-bottom:0; }

    .item-line:hover{ background:var(--panel2); }

    .item-line.selected{
      background:var(--border2);
      box-shadow:inset 0 0 0 1px var(--border);
    }

    .item-section-tag{
      background:var(--border);
      color:#8b949e;
      font-size:10px;
      padding:1px 6px;
      border-radius:6px;
      white-space:nowrap;
      flex-shrink:0;

      user-select:none;
      -webkit-user-select:none;
    }

    .item-text{
      flex:1;
      white-space:pre-wrap;
      word-break:break-word;
      cursor:text;
      user-select:text;
      -webkit-user-select:text;
    }

    /* 4) Кнопка переноса (видна только у выбранной строки) */
    .move-btn{
      width:30px;
      height:30px;
      border-radius:10px;
      border:1px solid transparent;
      background:transparent;
      color:var(--muted);
      cursor:pointer;
      display:grid;
      place-items:center;
      flex:0 0 auto;
      -webkit-tap-highlight-color:var(--tap);

      opacity:0;
      pointer-events:none;
      transition:opacity .12s, background .12s, border-color .12s, color .12s;
    }
    .item-line.selected .move-btn{
      opacity:1;
      pointer-events:auto;
    }
    .move-btn:hover{
      color:var(--text);
      background:#0b0f15;
      border-color:var(--border);
    }

    /* ===== Edit ===== */
    .hidden{ display:none; }

    .edit-hint{
      font-size:11px;
      color:var(--muted);
      padding:8px 15px;
      border-bottom:1px solid var(--border);
      background:var(--panel2);
    }

    .content-edit{
      width:100%;
      min-height:420px;
      border:none;
      background:var(--bg);
      color:var(--text);
      padding:14px 15px;
      font-size:14px;
      font-family:inherit;
      line-height:1.6;
      resize:vertical;
    }
    .content-edit:focus{ outline:none; }

    .edit-panel{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      padding:10px 15px;
      border-top:1px solid var(--border);
      background:var(--panel2);
    }

    .edit-panel button{
      width:42px;
      height:42px;
      border:none;
      border-radius:var(--r10);
      cursor:pointer;
      display:grid;
      place-items:center;
      color:white;
      -webkit-tap-highlight-color:var(--tap);
    }
    .btn-cancel{ background:var(--border); }
    .btn-save{ background:var(--green); }

    .counter{
      text-align:right;
      padding:10px 15px;
      color:var(--muted2);
      font-size:12px;
      border-top:1px solid var(--border);
      background:var(--panel2);
    }

    /* ===== Dropdowns ===== */
    .dropdown-menu{
      position:absolute;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--r10);
      z-index:120;
      overflow:hidden;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }

    .dropdown-menu.section-menu{ padding:8px 0; min-width:240px; }
    .dropdown-menu.sort-menu{ padding:6px 0; width:170px; min-width:170px; }
    .dropdown-menu.settings-menu{ padding:14px; width:260px; min-width:260px; }

    .menu-option{
      padding:8px 14px;
      cursor:pointer;
      font-size:14px;
      display:flex;
      align-items:center;
      gap:10px;
      user-select:none;
      -webkit-tap-highlight-color:var(--tap);
    }
    .menu-option:hover{ background:var(--border2); }
    .menu-option.active{ color:var(--blue); }

    .menu-option.all-sections{
      border-bottom:1px solid var(--border);
      margin-bottom:6px;
      padding-bottom:10px;
    }

    .menu-divider{ border-top:1px solid var(--border); margin:6px 0; }

    .menu-option.add-new{ color:var(--blue); }

    /* delete confirm inline (confirm appears LEFT of delete) */
    .menu-actions{
      margin-left:auto;
      display:flex;
      gap:6px;
      align-items:center;
    }

    .mini-btn{
      width:26px;
      height:26px;
      border-radius:8px;
      display:grid;
      place-items:center;
      background:transparent;
      border:1px solid transparent;
      color:var(--muted);
      cursor:pointer;
      -webkit-tap-highlight-color:var(--tap);
    }
    .mini-btn:hover{ background:var(--panel2); color:var(--text); border-color:var(--border); }
    .mini-btn.danger:hover{ color:var(--red); border-color:#3d1f22; }
    .mini-btn.confirm{ color:#7ee787; }
    .mini-btn.confirm:hover{ border-color:#1d3b22; background:#0f1a12; }
    .mini-btn.hidden{ display:none; }

    .new-section-input{
      width:calc(100% - 28px);
      margin:8px 14px;
      background:var(--bg);
      border:1px solid var(--border);
      border-radius:var(--r10);
      color:var(--text);
      padding:8px 10px;
      font-size:13px;
    }
    .new-section-input:focus{ outline:none; border-color:var(--blue); }

    .sort-dir{ margin-left:auto; color:#8b949e; font-size:12px; }

    .settings-menu label{
      display:block;
      font-size:11px;
      color:#8b949e;
      margin-bottom:4px;
    }
    .settings-menu input{
      width:100%;
      background:var(--bg);
      border:1px solid var(--border);
      border-radius:var(--r10);
      color:var(--text);
      padding:8px 10px;
      font-size:13px;
      margin-bottom:12px;
    }
    .settings-menu input:focus{ outline:none; border-color:var(--blue); }

    .settings-buttons{ display:flex; gap:8px; }
    .settings-btn{
      flex:1;
      height:42px;
      border:none;
      border-radius:var(--r10);
      cursor:pointer;
      display:grid;
      place-items:center;
      color:white;
      -webkit-tap-highlight-color:var(--tap);
    }
    .btn-primary{ background:var(--green); }
    .btn-share{ background:#1f6feb; }

    .setup-prompt{ padding:16px; color:#8b949e; text-align:center; }

    /* ===== Undo bar ===== */
    .undo-bar{
      position:fixed;
      left:50%;
      bottom:14px;
      transform:translateX(-50%);
      z-index:200;

      display:flex;
      align-items:center;
      gap:10px;

      background:#0b0f15;
      border:1px solid var(--border);
      box-shadow:0 10px 25px rgba(0,0,0,.35);
      border-radius:999px;
      padding:8px 10px 8px 12px;
      max-width:min(92vw, 560px);
    }
    .undo-text{
      color:#8b949e;
      font-size:13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 420px;
    }
    .undo-btn{
      width:34px;
      height:34px;
      border-radius:999px;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      cursor:pointer;
      display:grid;
      place-items:center;
      -webkit-tap-highlight-color:var(--tap);
    }
    .undo-btn:hover{ border-color:var(--blue); }
    .undo-bar.hidden{ display:none; }
  </style>
</head>

<body>
  <!-- Mono SVG icons -->
  <svg aria-hidden="true" style="position:absolute;width:0;height:0;overflow:hidden">
    <symbol id="i-chevron-down" viewBox="0 0 16 16">
      <path d="M4.2 6.2a1 1 0 0 1 1.4 0L8 8.6l2.4-2.4a1 1 0 1 1 1.4 1.4l-3.1 3.1a1 1 0 0 1-1.4 0L4.2 7.6a1 1 0 0 1 0-1.4z"></path>
    </symbol>

    <symbol id="i-sort" viewBox="0 0 16 16">
      <path d="M6 2a1 1 0 0 1 1 1v9.6l1.3-1.3a1 1 0 1 1 1.4 1.4l-3 3a1 1 0 0 1-1.4 0l-3-3a1 1 0 0 1 1.4-1.4L5 12.6V3a1 1 0 0 1 1-1z"></path>
      <path d="M10 14a1 1 0 0 1-1-1V3.4L7.7 4.7a1 1 0 1 1-1.4-1.4l3-3a1 1 0 0 1 1.4 0l3 3a1 1 0 0 1-1.4 1.4L11 3.4V13a1 1 0 0 1-1 1z" opacity=".35"></path>
    </symbol>

    <symbol id="i-pencil" viewBox="0 0 16 16">
      <path d="M12.9 1.7a2 2 0 0 1 2.8 2.8l-9 9L3 14l.5-3.7 9.4-8.6zM4.6 10.9 4.3 13l2.1-.3 8.2-8.2-1.8-1.8-8.2 8.2z"></path>
    </symbol>

    <symbol id="i-x" viewBox="0 0 16 16">
      <path d="M4 4a1 1 0 0 1 1.4 0L8 6.6 10.6 4A1 1 0 1 1 12 5.4L9.4 8 12 10.6A1 1 0 0 1 10.6 12L8 9.4 5.4 12A1 1 0 0 1 4 10.6L6.6 8 4 5.4A1 1 0 0 1 4 4z"></path>
    </symbol>

    <symbol id="i-check" viewBox="0 0 16 16">
      <path d="M6.5 11.2 3.3 8a1 1 0 1 1 1.4-1.4l1.8 1.8 4.8-4.8a1 1 0 1 1 1.4 1.4l-6.2 6.2a1 1 0 0 1-1.4 0z"></path>
    </symbol>

    <symbol id="i-gear" viewBox="0 0 16 16">
      <path d="M9.7 1.2 10 2.6c.3.1.6.3.9.5l1.3-.7 1.1 2-1.1 1c.1.3.2.6.2 1s-.1.7-.2 1l1.1 1-1.1 2-1.3-.7c-.3.2-.6.4-.9.5l-.3 1.4H6.3L6 13.4c-.3-.1-.6-.3-.9-.5l-1.3.7-1.1-2 1.1-1c-.1-.3-.2-.6-.2-1s.1-.7.2-1l-1.1-1 1.1-2 1.3.7c.3-.2.6-.4.9-.5l.3-1.4h3.4zM8 10.5A2.5 2.5 0 1 0 8 5.5a2.5 2.5 0 0 0 0 5z"></path>
    </symbol>

    <symbol id="i-copy" viewBox="0 0 16 16">
      <path d="M5 2.5A2.5 2.5 0 0 1 7.5 0h6A2.5 2.5 0 0 1 16 2.5v6A2.5 2.5 0 0 1 13.5 11h-6A2.5 2.5 0 0 1 5 8.5v-6zM7.5 2A.5.5 0 0 0 7 2.5v6a.5.5 0 0 0 .5.5h6a.5.5 0 0 0 .5-.5v-6a.5.5 0 0 0-.5-.5h-6z"></path>
      <path d="M0 6.5A2.5 2.5 0 0 1 2.5 4H4v2H2.5a.5.5 0 0 0-.5.5v6a.5.5 0 0 0 .5.5h6a.5.5 0 0 0 .5-.5V11h2v1.5A2.5 2.5 0 0 1 8.5 15h-6A2.5 2.5 0 0 1 0 12.5v-6z" opacity=".45"></path>
    </symbol>

    <!-- 2) Undo icon -->
    <symbol id="i-undo" viewBox="0 0 16 16">
      <path d="M7 4H3.9l1.6-1.6A1 1 0 0 0 4.1 1L1 4.1a1 1 0 0 0 0 1.4L4.1 8.6A1 1 0 1 0 5.5 7.2L3.9 5.6H7c3 0 5.5 2.1 5.5 4.8S10 15.2 7 15.2H6a1 1 0 1 0 0 2h1c4.1 0 7.5-2.9 7.5-6.8S11.1 4 7 4z" transform="translate(0,-1.2)"></path>
    </symbol>

    <!-- 4) Move icon -->
    <symbol id="i-move" viewBox="0 0 16 16">
      <path d="M6 3a1 1 0 0 1 1-1h6a2 2 0 0 1 2 2v6a1 1 0 1 1-2 0V4H7a1 1 0 0 1-1-1z"></path>
      <path d="M9.5 7a1 1 0 0 1 .7 1.7l-2 2a1 1 0 0 1-1.4 0l-2-2A1 1 0 1 1 6.2 7.3L7 8.1V3a1 1 0 1 1 2 0v5.1l.8-.8A1 1 0 0 1 9.5 7z" opacity=".55"></path>
      <path d="M2 6a2 2 0 0 1 2-2h2a1 1 0 1 1 0 2H4v6h6v-2a1 1 0 1 1 2 0v2a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6z" opacity=".55"></path>
    </symbol>

    <!-- 6) Eye icons -->
    <symbol id="i-eye" viewBox="0 0 16 16">
      <path d="M8 3C3.5 3 1 8 1 8s2.5 5 7 5 7-5 7-5-2.5-5-7-5zm0 8a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"></path>
      <path d="M8 6.5A1.5 1.5 0 1 0 8 9.5a1.5 1.5 0 0 0 0-3z"></path>
    </symbol>
    <symbol id="i-eye-off" viewBox="0 0 16 16">
      <path d="M2 2a1 1 0 0 1 1.4 0l10.6 10.6A1 1 0 1 1 12.6 14L11 12.4C9.9 13 8.8 13.3 8 13.3 3.5 13.3 1 8.3 1 8.3c.6-1.2 1.7-2.8 3.3-3.9L2 2zm4 4 1.1 1.1A1.9 1.9 0 0 0 7 8a1.9 1.9 0 0 0 .9 1.6L9 10.7A3 3 0 0 1 6 6z"></path>
      <path d="M8 3.3c4.5 0 7 5 7 5-.5 1-1.3 2.3-2.5 3.4L10.9 10c.6-.5 1.1-1.1 1.5-1.7 0 0-2.5-3.9-4.4-3.9-.3 0-.6 0-1 .1L5.4 3.9c.8-.4 1.7-.6 2.6-.6z"></path>
    </symbol>
  </svg>

  <div class="container" id="container">
    <header>
      <div class="header-row">
        <button class="section-btn" id="sectionBtn" onclick="toggleSectionMenu()">
          <span id="currentSectionName">Все</span>
          <svg class="icon small" viewBox="0 0 16 16"><use href="#i-chevron-down"></use></svg>
        </button>

        <!-- 6) Toggle only for "Все": include/exclude viewed sections -->
        <button class="all-toggle hidden" id="viewedToggleBtn" onclick="toggleShowViewed()" title="Показывать/скрывать просмотренное">
          <svg class="icon" viewBox="0 0 16 16"><use id="viewedToggleUse" href="#i-eye-off"></use></svg>
        </button>

        <!-- 3) Filter -->
        <div class="filter-wrap" title="Фильтр">
          <input class="filter-input" id="filterInput" placeholder="Фильтр" autocapitalize="off" autocomplete="off" spellcheck="false" />
          <button class="filter-clear hidden" id="filterClear" title="Очистить фильтр" onclick="clearFilter()">
            <svg class="icon small" viewBox="0 0 16 16"><use href="#i-x"></use></svg>
          </button>
        </div>

        <div class="header-buttons">
          <button class="icon-btn" id="sortBtn" onclick="toggleSort()" title="Сортировка">
            <svg class="icon"><use href="#i-sort"></use></svg>
          </button>

          <button class="icon-btn" id="editBtn" onclick="toggleEdit()" title="Редактировать">
            <svg class="icon"><use id="editUse" href="#i-pencil"></use></svg>
          </button>

          <button class="icon-btn" id="settingsBtn" onclick="toggleSettings()" title="Настройки">
            <svg class="icon"><use href="#i-gear"></use></svg>
          </button>
        </div>
      </div>
    </header>

    <div class="content-area">
      <div class="content-list" id="viewMode"></div>

      <div class="hidden" id="editMode">
        <div class="edit-hint hidden" id="editHint">[Раздел] Текст</div>
        <textarea class="content-edit" id="editor" placeholder="..."></textarea>
        <div class="edit-panel">
          <button class="btn-cancel" onclick="cancelEdit()" title="Отмена">
            <svg class="icon"><use href="#i-x"></use></svg>
          </button>
          <button class="btn-save" onclick="saveEdit()" title="Сохранить">
            <svg class="icon"><use href="#i-check"></use></svg>
          </button>
        </div>
      </div>

      <div class="counter" id="counter"></div>
    </div>

    <!-- Sections -->
    <div class="dropdown-menu section-menu hidden" id="sectionMenu">
      <div class="menu-option all-sections" onclick="selectSection('__all__')">Все</div>
      <div id="sectionList"></div>
      <div class="menu-divider"></div>
      <div class="menu-option add-new" onclick="showNewSectionInput()">+ Новый</div>
      <input
        type="text"
        class="new-section-input hidden"
        id="newSectionInput"
        placeholder="Название..."
        onkeydown="handleNewSection(event)"
      />
    </div>

    <!-- Sort (compact toggle direction) -->
    <div class="dropdown-menu sort-menu hidden" id="sortMenu">
      <div class="menu-option" data-key="manual" onclick="setSortKey('manual')">
        Вручную <span class="sort-dir"></span>
      </div>
      <div class="menu-option" data-key="date" onclick="setSortKey('date')">
        Дата <span class="sort-dir"></span>
      </div>
      <div class="menu-option" data-key="alpha" onclick="setSortKey('alpha')">
        А-Я <span class="sort-dir"></span>
      </div>
      <div class="menu-option" data-key="year" onclick="setSortKey('year')">
        Год <span class="sort-dir"></span>
      </div>
    </div>

    <!-- Settings -->
    <div class="dropdown-menu settings-menu hidden" id="settingsMenu">
      <label>Gist ID</label>
      <input type="text" id="inputGistId" placeholder="abc123..." />

      <label>Token</label>
      <input type="password" id="inputToken" placeholder="ghp_..." />

      <div class="settings-buttons">
        <button class="settings-btn btn-primary" onclick="saveSettings()" title="Применить">
          <svg class="icon"><use href="#i-check"></use></svg>
        </button>
        <button class="settings-btn btn-share" onclick="copyShareLink()" id="shareBtn" title="Скопировать ссылку">
          <svg class="icon"><use href="#i-copy"></use></svg>
        </button>
      </div>
    </div>
  </div>

  <!-- Undo bar -->
  <div class="undo-bar hidden" id="undoBar">
    <div class="undo-text" id="undoText"></div>
    <button class="undo-btn" id="undoBtn" title="Отменить удаление">
      <svg class="icon" viewBox="0 0 16 16"><use href="#i-undo"></use></svg>
    </button>
  </div>

  <script>
    // ===== CONFIG =====
    const VIEWED_PREFIX = "✓ ";                 // символ вместо слова "Просмотренное"
    const UNDO_MS = 10000;

    let GIST_ID = localStorage.getItem("gist_id") || "";
    let TOKEN = localStorage.getItem("github_token") || "";

    let currentSection = localStorage.getItem("current_section") || "__all__";
    let sortState = parseSortState(localStorage.getItem("sort_state")) || { key: "manual", dir: "desc" };

    let filterQuery = localStorage.getItem("filter_query") || "";

    // default: hide viewed in "Все"
    let showViewedInAll = (localStorage.getItem("show_viewed_all") ?? "0") === "1";

    let data = { sections: {} };
    let isEditing = false;

    const defaultSections = ["Фильмы", "Сериалы", "Аниме"];

    // view selection highlight
    let selectedKey = null; // `${section}|${index}`

    // pointer/text selection helper
    let pointer = { down:false, startX:0, startY:0, moved:false, startedAt:0 };

    // delete confirmation state
    let deleteArm = null;
    let deleteArmTimer = null;

    // undo state
    let undoTimer = null;
    let undoPayload = null; // {name, sectionData, prevCurrentSection}

    // edit context for filtered editing
    let editCtx = null; // {mode, filterLower, showViewedInAll, masksBySection? or mask?, section?}

    // ===== INIT =====
    async function init() {
      applyUrlSetupSilently();
      updateSettingsIcon();
      updateShareButton();
      setupFilterUI();
      updateViewedToggleUI();

      if (!GIST_ID || !TOKEN) {
        document.getElementById("viewMode").innerHTML = `<div class="setup-prompt">Откройте настройки</div>`;
        document.getElementById("counter").textContent = "";
        return;
      }

      await loadData();
      ensureDefaultSections();
      renderSectionList();
      updateSectionButton();
      render();
    }

    // ===== URL SETUP (silent) =====
    function applyUrlSetupSilently() {
      const params = new URLSearchParams(window.location.search);
      const setup = params.get("s");
      if (!setup) return;

      try {
        const decoded = atob(setup);
        const [gist, token] = decoded.split(":");
        if (gist && token) {
          localStorage.setItem("gist_id", gist);
          localStorage.setItem("github_token", token);
          GIST_ID = gist;
          TOKEN = token;
          window.history.replaceState({}, "", window.location.pathname);
        }
      } catch (_) {}
    }

    // ===== Filter =====
    function setupFilterUI() {
      const input = document.getElementById("filterInput");
      const clear = document.getElementById("filterClear");

      input.value = filterQuery;
      clear.classList.toggle("hidden", !filterQuery);

      input.oninput = () => {
        if (isEditing) return; // lock during edit
        filterQuery = input.value || "";
        localStorage.setItem("filter_query", filterQuery);
        clear.classList.toggle("hidden", !filterQuery);
        selectedKey = null;
        render();
      };

      input.onkeydown = (e) => {
        if (e.key === "Escape") {
          clearFilter();
          input.blur();
        }
      };
    }

    function setFilterLock(locked) {
      const input = document.getElementById("filterInput");
      const clear = document.getElementById("filterClear");
      input.disabled = locked;
      if (locked) clear.classList.add("hidden");
      else clear.classList.toggle("hidden", !filterQuery);
    }

    function clearFilter() {
      if (isEditing) return;
      filterQuery = "";
      localStorage.setItem("filter_query", "");
      const input = document.getElementById("filterInput");
      input.value = "";
      document.getElementById("filterClear").classList.add("hidden");
      selectedKey = null;
      render();
      input.focus();
    }

    // ===== Viewed toggle (only in All) =====
    function updateViewedToggleUI() {
      const btn = document.getElementById("viewedToggleBtn");
      const use = document.getElementById("viewedToggleUse");

      const shouldShow = currentSection === "__all__";
      btn.classList.toggle("hidden", !shouldShow);

      btn.classList.toggle("on", showViewedInAll);
      use.setAttribute("href", showViewedInAll ? "#i-eye" : "#i-eye-off");
    }

    function toggleShowViewed() {
      if (isEditing) return;
      showViewedInAll = !showViewedInAll;
      localStorage.setItem("show_viewed_all", showViewedInAll ? "1" : "0");
      selectedKey = null;
      updateViewedToggleUI();
      render();
    }

    // ===== Menu positioning =====
    function openMenu(menuId, anchorEl, align = "left") {
      closeAllMenus(menuId);

      const menu = document.getElementById(menuId);
      const container = document.getElementById("container");

      menu.classList.remove("hidden");
      menu.style.visibility = "hidden";

      const cRect = container.getBoundingClientRect();
      const aRect = anchorEl.getBoundingClientRect();
      const mRect = menu.getBoundingClientRect();

      const top = aRect.bottom - cRect.top + 8;
      let left = (align === "right")
        ? aRect.right - cRect.left - mRect.width
        : aRect.left - cRect.left;

      left = Math.max(0, Math.min(left, cRect.width - mRect.width));

      menu.style.top = `${top}px`;
      menu.style.left = `${left}px`;
      menu.style.visibility = "visible";
    }

    // ===== SETTINGS =====
    function toggleSettings() {
      if (isEditing) return;

      const menu = document.getElementById("settingsMenu");
      const btn = document.getElementById("settingsBtn");

      if (!menu.classList.contains("hidden")) {
        menu.classList.add("hidden");
        return;
      }

      document.getElementById("inputGistId").value = GIST_ID;
      document.getElementById("inputToken").value = TOKEN;
      updateShareButton();
      openMenu("settingsMenu", btn, "right");
    }

    function saveSettings() {
      const gistId = document.getElementById("inputGistId").value.trim();
      const token = document.getElementById("inputToken").value.trim();
      if (!gistId || !token) return;

      localStorage.setItem("gist_id", gistId);
      localStorage.setItem("github_token", token);
      GIST_ID = gistId;
      TOKEN = token;

      document.getElementById("settingsMenu").classList.add("hidden");
      updateSettingsIcon();
      updateShareButton();
      init();
    }

    function updateSettingsIcon() {
      document.getElementById("settingsBtn").classList.toggle("error", !GIST_ID || !TOKEN);
    }

    function updateShareButton() {
      document.getElementById("shareBtn").style.display = (GIST_ID && TOKEN) ? "grid" : "none";
    }

    function copyShareLink() {
      if (!GIST_ID || !TOKEN) return;
      const link = `${location.origin}${location.pathname}?s=${btoa(`${GIST_ID}:${TOKEN}`)}`;
      if (navigator.clipboard) navigator.clipboard.writeText(link);
      else {
        const ta = document.createElement("textarea");
        ta.value = link;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
      }
    }

    // ===== SECTIONS =====
    function toggleSectionMenu() {
      if (isEditing) return;

      const menu = document.getElementById("sectionMenu");
      const btn = document.getElementById("sectionBtn");

      if (!menu.classList.contains("hidden")) {
        menu.classList.add("hidden");
        document.getElementById("newSectionInput").classList.add("hidden");
        disarmDelete();
        return;
      }

      renderSectionList();
      document.getElementById("newSectionInput").classList.add("hidden");
      openMenu("sectionMenu", btn, "left");
    }

    function ensureDefaultSections() {
      if (Object.keys(data.sections).length) return;
      defaultSections.forEach((s) => (data.sections[s] = { items: [], modified: new Date().toISOString() }));
    }

    function renderSectionList() {
      const list = document.getElementById("sectionList");

      list.innerHTML = Object.keys(data.sections).map((name) => {
        const armed = (deleteArm === name);

        // confirm should appear LEFT of delete:
        // [confirm][delete]
        return `
          <div class="menu-option ${currentSection === name ? "active" : ""}" onclick="selectSection('${escapeQuotes(name)}')">
            <span>${escapeHtml(name)}</span>

            <span class="menu-actions" onclick="event.stopPropagation()">
              <button class="mini-btn confirm ${armed ? "" : "hidden"}" title="Подтвердить" onclick="confirmDelete('${escapeQuotes(name)}')">✓</button>
              <button class="mini-btn danger" title="Удалить" onclick="armDelete('${escapeQuotes(name)}')">×</button>
            </span>
          </div>
        `;
      }).join("");
    }

    function selectSection(name) {
      currentSection = name;
      localStorage.setItem("current_section", name);
      selectedKey = null;
      disarmDelete();
      updateSectionButton();
      updateViewedToggleUI();
      document.getElementById("sectionMenu").classList.add("hidden");
      render();
    }

    function updateSectionButton() {
      document.getElementById("currentSectionName").textContent =
        (currentSection === "__all__") ? "Все" : currentSection;
    }

    function showNewSectionInput() {
      const input = document.getElementById("newSectionInput");
      input.classList.remove("hidden");
      input.value = "";
      input.focus();
      disarmDelete();
    }

    function handleNewSection(e) {
      if (e.key === "Enter") {
        const name = e.target.value.trim();
        if (name && !data.sections[name]) {
          data.sections[name] = { items: [], modified: new Date().toISOString() };
          saveData();
          renderSectionList();
          selectSection(name);
        }
        e.target.classList.add("hidden");
      } else if (e.key === "Escape") {
        e.target.classList.add("hidden");
      }
    }

    // ===== Delete confirm + undo =====
    function armDelete(name) {
      if (Object.keys(data.sections).length <= 1) return;

      if (deleteArm === name) {
        disarmDelete();
        renderSectionList();
        return;
      }

      deleteArm = name;
      renderSectionList();

      if (deleteArmTimer) clearTimeout(deleteArmTimer);
      deleteArmTimer = setTimeout(() => {
        disarmDelete();
        renderSectionList();
      }, 6000);
    }

    function disarmDelete() {
      deleteArm = null;
      if (deleteArmTimer) clearTimeout(deleteArmTimer);
      deleteArmTimer = null;
    }

    function confirmDelete(name) {
      if (Object.keys(data.sections).length <= 1) return;
      if (!data.sections[name]) return;

      disarmDelete();

      if (undoTimer) clearTimeout(undoTimer);
      undoPayload = {
        name,
        sectionData: JSON.parse(JSON.stringify(data.sections[name])),
        prevCurrentSection: currentSection
      };

      delete data.sections[name];

      if (currentSection === name) {
        currentSection = "__all__";
        localStorage.setItem("current_section", "__all__");
        updateSectionButton();
        updateViewedToggleUI();
      }

      selectedKey = null;
      saveData();
      renderSectionList();
      render();

      showUndo(name);

      undoTimer = setTimeout(() => {
        hideUndo();
        undoPayload = null;
        undoTimer = null;
      }, UNDO_MS);
    }

    function showUndo(name) {
      document.getElementById("undoText").textContent = `Раздел удалён: ${name}`;
      document.getElementById("undoBar").classList.remove("hidden");
    }
    function hideUndo() {
      document.getElementById("undoBar").classList.add("hidden");
    }

    document.getElementById("undoBtn").addEventListener("click", () => {
      if (!undoPayload) return;

      let restoreName = undoPayload.name;
      if (data.sections[restoreName]) {
        let i = 2;
        while (data.sections[`${restoreName} (${i})`]) i++;
        restoreName = `${restoreName} (${i})`;
      }

      data.sections[restoreName] = undoPayload.sectionData;

      if (undoPayload.prevCurrentSection === undoPayload.name) {
        currentSection = restoreName;
        localStorage.setItem("current_section", restoreName);
        updateSectionButton();
        updateViewedToggleUI();
      }

      saveData();
      renderSectionList();
      render();

      if (undoTimer) clearTimeout(undoTimer);
      undoTimer = null;
      undoPayload = null;
      hideUndo();
    });

    // ===== SORT (compact toggle direction) =====
    function toggleSort() {
      if (isEditing) return;

      const menu = document.getElementById("sortMenu");
      const btn = document.getElementById("sortBtn");

      if (!menu.classList.contains("hidden")) {
        menu.classList.add("hidden");
        return;
      }

      openMenu("sortMenu", btn, "right");
      updateSortMenuUI();
    }

    function setSortKey(key) {
      if (key === "manual") {
        sortState = { key: "manual", dir: "desc" };
      } else if (sortState.key === key) {
        sortState.dir = (sortState.dir === "asc") ? "desc" : "asc";
      } else {
        sortState = { key, dir: defaultDirForKey(key) };
      }

      localStorage.setItem("sort_state", `${sortState.key}:${sortState.dir}`);
      selectedKey = null;
      updateSortMenuUI();
      document.getElementById("sortMenu").classList.add("hidden");
      render();
    }

    function defaultDirForKey(key) {
      if (key === "alpha") return "asc";
      return "desc";
    }

    function updateSortMenuUI() {
      document.querySelectorAll("#sortMenu .menu-option").forEach((el) => {
        const key = el.dataset.key;
        const dirSpan = el.querySelector(".sort-dir");
        const active = (key === sortState.key);
        el.classList.toggle("active", active);

        if (!dirSpan) return;
        if (!active || key === "manual") dirSpan.textContent = "";
        else dirSpan.textContent = (sortState.dir === "asc") ? "↑" : "↓";
      });
    }

    function parseSortState(str) {
      if (!str) return null;
      const [key, dir] = String(str).split(":");
      if (!key) return null;
      return { key, dir: dir === "asc" ? "asc" : "desc" };
    }

    function getSortedItems(items) {
      if (!items || sortState.key === "manual") return items;

      const sorted = [...items];
      const getText = (x) => (x.text ?? x);

      switch (sortState.key) {
        case "alpha":
          sorted.sort((a, b) => getText(a).localeCompare(getText(b), "ru"));
          if (sortState.dir === "desc") sorted.reverse();
          break;

        case "year":
          sorted.sort((a, b) => {
            const yA = (getText(a).match(/\((\d{4})\)/) || [, 0])[1];
            const yB = (getText(b).match(/\((\d{4})\)/) || [, 0])[1];
            return Number(yA) - Number(yB);
          });
          if (sortState.dir === "desc") sorted.reverse();
          break;

        case "date":
          // "дата" как порядок добавления
          if (sortState.dir === "desc") sorted.reverse();
          break;
      }

      return sorted;
    }

    // ===== API =====
    async function loadData() {
      try {
        const res = await fetch(`https://api.github.com/gists/${GIST_ID}`, {
          headers: { Authorization: `token ${TOKEN}` },
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        const gist = await res.json();
        if (gist.files?.["contents.json"]) {
          const loaded = JSON.parse(gist.files["contents.json"].content);
          if (loaded.users && !loaded.sections) data.sections = loaded.users; // migration
          else data = loaded.sections ? loaded : { sections: {} };
        } else {
          data = { sections: {} };
          await saveData();
        }
      } catch (e) {
        console.error(e);
        data = { sections: {} };
      }
    }

    async function saveData() {
      if (!TOKEN || !GIST_ID) return;
      try {
        await fetch(`https://api.github.com/gists/${GIST_ID}`, {
          method: "PATCH",
          headers: {
            Authorization: `token ${TOKEN}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            files: { "contents.json": { content: JSON.stringify(data, null, 2) } },
          }),
        });
      } catch (e) {
        console.error(e);
      }
    }

    // ===== VIEWED helpers =====
    function isViewedSection(name) {
      return typeof name === "string" && name.startsWith(VIEWED_PREFIX);
    }

    function baseSectionName(name) {
      return isViewedSection(name) ? name.slice(VIEWED_PREFIX.length) : name;
    }

    function viewedSectionNameFor(sourceSection) {
      return VIEWED_PREFIX + baseSectionName(sourceSection);
    }

    // ===== EDIT (filtered editing supported) =====
    function toggleEdit() {
      if (!TOKEN || !GIST_ID) {
        toggleSettings();
        return;
      }
      isEditing ? cancelEdit() : startEdit();
    }

    function startEdit() {
      isEditing = true;
      selectedKey = null;

      // lock filter to avoid confusing edits
      setFilterLock(true);

      const editor = document.getElementById("editor");
      const hint = document.getElementById("editHint");
      document.getElementById("editUse").setAttribute("href", "#i-x");

      const filterLower = (filterQuery || "").trim().toLowerCase();

      if (currentSection === "__all__") {
        // build filtered list (no sort, stored order), respecting showViewedInAll
        const masksBySection = {};
        const lines = [];

        for (const section of Object.keys(data.sections)) {
          if (!showViewedInAll && isViewedSection(section)) continue;

          const items = data.sections[section]?.items || [];
          const mask = items.map(it => !filterLower || String(it).toLowerCase().includes(filterLower));

          if (mask.some(Boolean)) masksBySection[section] = mask;

          for (let i = 0; i < items.length; i++) {
            if (mask[i]) lines.push(`[${section}] ${items[i]}`);
          }
        }

        editor.value = lines.join("\n");
        hint.classList.remove("hidden");

        editCtx = { mode: "all", filterLower, showViewedInAll, masksBySection };

      } else {
        const section = currentSection;
        const orig = data.sections[section]?.items || [];
        const mask = orig.map(it => !filterLower || String(it).toLowerCase().includes(filterLower));
        const lines = orig.filter((_, i) => mask[i]);

        editor.value = lines.join("\n");
        hint.classList.add("hidden");

        editCtx = { mode: "section", section, filterLower, mask };
      }

      document.getElementById("viewMode").classList.add("hidden");
      document.getElementById("editMode").classList.remove("hidden");
      editor.focus();
    }

    function cancelEdit() {
      isEditing = false;
      editCtx = null;

      setFilterLock(false);

      document.getElementById("viewMode").classList.remove("hidden");
      document.getElementById("editMode").classList.add("hidden");
      document.getElementById("editHint").classList.add("hidden");
      document.getElementById("editUse").setAttribute("href", "#i-pencil");
    }

    function mergeByMask(original, mask, replacement) {
      const out = [];
      let ri = 0;

      const m = Array.isArray(mask) ? mask : new Array(original.length).fill(false);

      for (let i = 0; i < original.length; i++) {
        if (m[i]) {
          if (ri < replacement.length) out.push(replacement[ri++]);
          // else: delete this matched item
        } else {
          out.push(original[i]);
        }
      }
      while (ri < replacement.length) out.push(replacement[ri++]); // new items appended
      return out;
    }

    function parseAllEditorLines(lines) {
      // returns { bySection: {sectionName: [items...] } }
      const bySection = {};
      let lastSection = Object.keys(data.sections)[0] || "Раздел";

      for (const line of lines) {
        const m = line.match(/^\[([^\]]+)\]\s*(.*)$/);
        if (m) {
          const section = m[1].trim();
          const item = (m[2] || "").trim();
          if (!section) continue;
          if (!bySection[section]) bySection[section] = [];
          if (item) bySection[section].push(item);
          lastSection = section;
        } else {
          const item = line.trim();
          if (!item) continue;
          if (!bySection[lastSection]) bySection[lastSection] = [];
          bySection[lastSection].push(item);
        }
      }
      return { bySection };
    }

    async function saveEdit() {
      const text = document.getElementById("editor").value;
      const lines = text.split("\n").map(s => s.trim()).filter(Boolean);

      if (!editCtx) return;

      if (editCtx.mode === "section") {
        const section = editCtx.section;
        const orig = data.sections[section]?.items || [];
        const replacement = lines;
        const merged = mergeByMask(orig, editCtx.mask, replacement);

        data.sections[section] = {
          items: merged,
          modified: new Date().toISOString()
        };

      } else if (editCtx.mode === "all") {
        const parsed = parseAllEditorLines(lines);
        const newBySection = parsed.bySection;

        // union of sections: existing + newly referenced
        const allSections = new Set([...Object.keys(data.sections), ...Object.keys(newBySection)]);

        for (const section of allSections) {
          const orig = data.sections[section]?.items || [];
          const mask = editCtx.masksBySection[section] || new Array(orig.length).fill(false);
          const replacement = newBySection[section] || [];
          const merged = mergeByMask(orig, mask, replacement);

          if (!data.sections[section]) {
            data.sections[section] = { items: [], modified: new Date().toISOString() };
          }
          data.sections[section].items = merged;
          data.sections[section].modified = new Date().toISOString();
        }
      }

      await saveData();
      renderSectionList();
      cancelEdit();
      render();
    }

    // ===== MOVE to viewed (4+5) =====
    function moveItemToViewed(section, index) {
      if (!data.sections[section]) return;
      if (isViewedSection(section)) return; // already viewed

      const srcItems = data.sections[section].items || [];
      let idx = Number(index);

      if (!Number.isFinite(idx) || idx < 0 || idx >= srcItems.length) return;

      const itemText = srcItems[idx];

      // remove from source
      srcItems.splice(idx, 1);
      data.sections[section].modified = new Date().toISOString();

      // destination
      const dest = viewedSectionNameFor(section);
      if (!data.sections[dest]) data.sections[dest] = { items: [], modified: new Date().toISOString() };
      data.sections[dest].items.push(itemText);
      data.sections[dest].modified = new Date().toISOString();

      selectedKey = null;
      saveData();
      renderSectionList();
      render();
    }

    // ===== RENDER =====
    function shouldIncludeSectionInAll(name) {
      if (currentSection !== "__all__") return true;
      if (showViewedInAll) return true;
      return !isViewedSection(name);
    }

    function applyFilter(items) {
      const q = (filterQuery || "").trim().toLowerCase();
      if (!q) return items;
      return items.filter(it => String(it.text || "").toLowerCase().includes(q));
    }

    function buildItemsForView() {
      let items = [];
      if (currentSection === "__all__") {
        for (const section of Object.keys(data.sections)) {
          if (!shouldIncludeSectionInAll(section)) continue;
          const arr = data.sections[section]?.items || [];
          for (let i = 0; i < arr.length; i++) {
            items.push({ text: arr[i], section, index: i });
          }
        }
      } else {
        const arr = (data.sections[currentSection]?.items || []);
        for (let i = 0; i < arr.length; i++) {
          items.push({ text: arr[i], section: currentSection, index: i });
        }
      }
      items = applyFilter(items);
      items = getSortedItems(items);
      return items;
    }

    function render() {
      const view = document.getElementById("viewMode");
      const items = buildItemsForView();

      if (!items.length) {
        view.innerHTML = "";
        document.getElementById("counter").textContent = "0";
        return;
      }

      // if current selectedKey doesn't exist anymore, drop it
      const keySet = new Set(items.map(it => `${it.section}|${it.index}`));
      if (selectedKey && !keySet.has(selectedKey)) selectedKey = null;

      const inViewedSection = (currentSection !== "__all__" && isViewedSection(currentSection));

      view.innerHTML = items.map((it) => {
        const key = `${it.section}|${it.index}`;
        const selected = selectedKey === key;

        const showTag = (currentSection === "__all__");
        const canMove = !inViewedSection && !isViewedSection(it.section);

        return `
          <div class="item-line ${selected ? "selected" : ""}"
               data-key="${escapeAttr(key)}"
               data-section="${escapeAttr(it.section)}"
               data-index="${String(it.index)}">
            ${showTag ? `<span class="item-section-tag">${escapeHtml(it.section)}</span>` : ""}
            <span class="item-text">${escapeHtml(it.text)}</span>
            ${canMove ? `
              <button class="move-btn" title="Переместить в ${escapeHtml(viewedSectionNameFor(it.section))}" data-action="move">
                <svg class="icon" viewBox="0 0 16 16"><use href="#i-move"></use></svg>
              </button>
            ` : `<span style="width:30px;flex:0 0 auto;"></span>`}
          </div>
        `;
      }).join("");

      document.getElementById("counter").textContent = String(items.length);
    }

    // ===== View mode selection + move button =====
    const viewModeEl = document.getElementById("viewMode");

    viewModeEl.addEventListener("pointerdown", (e) => {
      if (isEditing) return;
      pointer.down = true;
      pointer.moved = false;
      pointer.startX = e.clientX;
      pointer.startY = e.clientY;
      pointer.startedAt = Date.now();
    });

    viewModeEl.addEventListener("pointermove", (e) => {
      if (!pointer.down) return;
      if (Math.hypot(e.clientX - pointer.startX, e.clientY - pointer.startY) > 10) {
        pointer.moved = true;
      }
    });

    viewModeEl.addEventListener("pointerup", () => {
      pointer.down = false;
    });

    viewModeEl.addEventListener("click", (e) => {
      if (isEditing) return;

      // 4) move action
      const moveBtn = e.target.closest("[data-action='move']");
      if (moveBtn) {
        e.stopPropagation();
        const line = moveBtn.closest(".item-line");
        if (!line) return;
        moveItemToViewed(line.dataset.section, line.dataset.index);
        return;
      }

      const line = e.target.closest(".item-line");
      if (!line) return;

      // if user selected text - don't toggle selection
      const sel = window.getSelection ? window.getSelection() : null;
      if (sel && !sel.isCollapsed) return;

      // ignore long press & drag/scroll gestures
      const longPress = pointer.startedAt && (Date.now() - pointer.startedAt > 350);
      if (longPress) return;
      if (pointer.moved) return;

      const key = line.dataset.key;
      selectedKey = (selectedKey === key) ? null : key;

      document.querySelectorAll("#viewMode .item-line.selected").forEach(el => el.classList.remove("selected"));
      if (selectedKey) line.classList.add("selected");
    });

    // ===== Close menus =====
    function closeAllMenus(except) {
      ["sortMenu", "settingsMenu", "sectionMenu"].forEach((id) => {
        if (id !== except) document.getElementById(id).classList.add("hidden");
      });
    }

    document.addEventListener("click", (e) => {
      if (!e.target.closest(".dropdown-menu") && !e.target.closest(".icon-btn") && !e.target.closest(".section-btn") && !e.target.closest(".all-toggle")) {
        closeAllMenus();
        disarmDelete();
        renderSectionList();
      }
    });

    window.addEventListener("scroll", () => {
      closeAllMenus();
      disarmDelete();
    }, { passive: true });

    // ===== Utils =====
    function escapeHtml(str) {
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }
    function escapeAttr(str) { return escapeHtml(str).replaceAll("`", "&#096;"); }
    function escapeQuotes(str) { return String(str).replaceAll("\\", "\\\\").replaceAll("'", "\\'"); }

    init();
  </script>
</body>
</html>
